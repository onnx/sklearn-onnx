
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>skl2onnx.common._topology &#8212; sklearn-onnx 1.9.1.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/readable.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-rendered-html.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sklearn-onnx 1.9.1.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../skl2onnx.html" accesskey="U">skl2onnx</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">skl2onnx.common._topology</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for skl2onnx.common._topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-License-Identifier: Apache-2.0</span>


<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">onnx</span> <span class="kn">import</span> <span class="n">onnx_pb</span> <span class="k">as</span> <span class="n">onnx_proto</span>
<span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa</span>
    <span class="n">DataType</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>
    <span class="n">FloatType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span>
    <span class="n">DictionaryType</span><span class="p">,</span> <span class="n">FloatTensorType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">Int64TensorType</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">StringTensorType</span><span class="p">,</span> <span class="n">DoubleTensorType</span><span class="p">,</span>
    <span class="n">Int32TensorType</span><span class="p">,</span> <span class="n">BooleanTensorType</span><span class="p">,</span>
    <span class="n">DoubleTensorType</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Int8TensorType</span><span class="p">,</span> <span class="n">UInt8TensorType</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Int8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">UInt8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_opset_number_from_onnx</span><span class="p">,</span>
    <span class="n">get_latest_tested_opset_version</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..proto.onnx_helper_modified</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">make_graph</span><span class="p">,</span> <span class="n">make_model</span><span class="p">,</span> <span class="n">make_tensor_value_info</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_registration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">MissingShapeCalculator</span><span class="p">,</span> <span class="n">MissingConverter</span>
<span class="kn">from</span> <span class="nn">._container</span> <span class="kn">import</span> <span class="n">ModelComponentContainer</span><span class="p">,</span> <span class="n">_build_options</span>
<span class="kn">from</span> <span class="nn">.interface</span> <span class="kn">import</span> <span class="n">OperatorBase</span>
<span class="kn">from</span> <span class="nn">.onnx_optimisation_identity</span> <span class="kn">import</span> <span class="n">onnx_remove_node_identity</span>
<span class="n">type_fct</span> <span class="o">=</span> <span class="nb">type</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.topology</span> <span class="kn">import</span> <span class="n">OPSET_TO_IR_VERSION</span>
    <span class="k">assert</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
    <span class="n">OPSET_TO_IR_VERSION</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="mi">13</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">:</span> <span class="mi">7</span>
    <span class="p">}</span>

<span class="n">OPSET_ML_TO_OPSET</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">13</span><span class="p">}</span>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable which holds any data defined</span>
<span class="sd">    from *ONNX* types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param raw_name: A string indicating the variable&#39;s name in the</span>
<span class="sd">                         original model. Usually, it&#39;s the seed string</span>
<span class="sd">                         used to created its ONNX name (i.e., the</span>
<span class="sd">                         field *onnx_name* below).</span>
<span class="sd">        :param onnx_name: A string indicating the variable&#39;s name in</span>
<span class="sd">                          the converted model</span>
<span class="sd">        :param scope: A string. It&#39;s the name of the scope where this</span>
<span class="sd">                      variable is declared</span>
<span class="sd">        :param type: A type object defined in .common.data_types.py;</span>
<span class="sd">                     e.g., FloatTensorType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">raw_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;raw_name must be a string not &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">raw_name</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">onnx_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;raw_name must be a string not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">not_none</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shape</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;A variable cannot be empty, raw_name=</span><span class="si">%r</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;onnx_name=</span><span class="si">%r</span><span class="s2">, type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span> <span class="o">=</span> <span class="n">raw_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="c1"># The following fields are bool variables used in parsing and</span>
        <span class="c1"># compiling stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">DataType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;shape must be a DataType not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be a tuple or a list not &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_fct</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must contains integers not &quot;</span>
                                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_first_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first dimension (batch dimension) or</span>
<span class="sd">        None if not specified (shape is empty).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique variable ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Variable(raw_name=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, type=</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_pb</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a data type from a protobuf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_dim</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># dim_value is 0 when it is 0 or undefined</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="s2">&quot;0&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">get_dim</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">))]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Variable</span><span class="o">.</span><span class="n">from_pb</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">elem_type</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">BooleanTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">DoubleTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">StringTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int64TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int32TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">UInt8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">UInt8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">Int8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; (elem_type=</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">),</span> <span class="n">elem</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; as &quot;</span>
                                      <span class="s2">&quot;a string (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                          <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ty</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Enables expression such as `a,b = self`.&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Unreachable element at index </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="n">OperatorBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an operator available in *ONNX*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param onnx_name: A unique ID, which is a string</span>
<span class="sd">        :param scope: The name of the scope where this operator is</span>
<span class="sd">                      declared. It&#39;s a string.</span>
<span class="sd">        :param type: A object which uniquely characterizes the type of</span>
<span class="sd">                     this operator. For example, it can be a string,</span>
<span class="sd">                     pooling, if this operator is associated with a</span>
<span class="sd">                     CoreML pooling layer.</span>
<span class="sd">        :param raw_operator: The original operator which defines this operator;</span>
<span class="sd">                             for example, a scikit-learn Imputer and</span>
<span class="sd">                             a CoreML Normalizer.</span>
<span class="sd">        :param target_opset: The target opset number for the converted model.</span>
<span class="sd">        :param scope_inst: :class:`Scope` instance the operator belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Parameter raw_operator must be an object not &quot;</span>
                               <span class="s2">&quot;a string &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">))</span>
        <span class="c1"># operator name in the converted model, if raw_operator</span>
        <span class="c1"># is not None, output_shapes can be guessed</span>
        <span class="c1"># from the raw model. Otherwise, it can be guessed</span>
        <span class="c1"># from the input shapes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">raw_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_inst</span> <span class="o">=</span> <span class="n">scope_inst</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Operator(type=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, inputs=&#39;</span><span class="si">{2}</span><span class="s2">&#39;, &quot;</span>
                <span class="s2">&quot;outputs=&#39;</span><span class="si">{3}</span><span class="s2">&#39;, raw_operator=</span><span class="si">{4}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span>
                    <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
                    <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique operator ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all input variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all output variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original operator/layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span>

    <span class="k">def</span> <span class="nf">infer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke a core inference function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="n">shape_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Scope"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope">[docs]</a><span class="k">class</span> <span class="nc">Scope</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Every node of an *ONNX* graph must be unique. This class holds the list</span>
<span class="sd">    of existing name for every node already defined in graph. It also</span>
<span class="sd">    provides functions to create a unique unused name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">variable_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">operator_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: A string, the unique ID of this scope in a</span>
<span class="sd">                     Topology object</span>
<span class="sd">        :param parent_scopes: A list of Scope objects. The last element</span>
<span class="sd">                              should be the direct parent scope (i.e.,</span>
<span class="sd">                              where this scope is declared).</span>
<span class="sd">        :param variable_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of variables</span>
<span class="sd">        :param operator_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of operators</span>
<span class="sd">        :param target_opset: The target opset number for the converted</span>
<span class="sd">                             model.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying</span>
<span class="sd">                                the user customized shape calculator</span>
<span class="sd">        :param options: see :ref:`l-conv-options`</span>
<span class="sd">        :param registered_models: registered models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_scopes</span> <span class="o">=</span> <span class="n">parent_scopes</span> <span class="k">if</span> <span class="n">parent_scopes</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">variable_name_set</span> <span class="k">if</span> <span class="n">variable_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">operator_name_set</span> <span class="k">if</span> <span class="n">operator_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="n">custom_shape_calculators</span>

        <span class="c1"># An one-to-many map from raw variable name to ONNX variable</span>
        <span class="c1"># names. It looks like</span>
        <span class="c1"># (key, value) = (raw_name, [onnx_name, onnx_name1, onnx_name2, ..., onnx_nameN]) # noqa</span>
        <span class="c1"># The last name may hide all other names in this scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local variables defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, variable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local operators defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, operator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Additional options given to converters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># Registered models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>

        <span class="c1"># Reserved variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserved</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">):</span>
        <span class="s2">&quot;Returns variable with &#39;name&#39; or default value is not found.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">temp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new Scope with the same options but no names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_scopes</span><span class="p">,</span>
            <span class="n">target_opset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>
            <span class="n">registered_models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">has_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if a variable is already registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span>

    <span class="k">def</span> <span class="nf">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape calculator for the given model type.</span>

<span class="sd">        :param model_type: model type such as *LogisticRegression*</span>
<span class="sd">        :return: alias or None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Scope.get_unique_variable_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_variable_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique variable ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter seed must be a string not </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Scope.get_unique_operator_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_operator_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_operator_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique operator ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">declare_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function may create a new variable in this scope. If</span>
<span class="sd">        *raw_name* has been used to create other variables, the new</span>
<span class="sd">        variable will hide all other variables created using *raw_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get unique ID for the new variable</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">)</span>

        <span class="c1"># Create the variable</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

        <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="c1"># Hide existing variables with the same raw_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">reserve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keeps this name to be used by other converters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserved</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Name &#39;</span><span class="si">{}</span><span class="s2">&#39; already reserved.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reserved</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">raw_name</span>

    <span class="k">def</span> <span class="nf">unreserve_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes a name from the reserved list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserved</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Name &#39;</span><span class="si">{}</span><span class="s2">&#39; not reserved.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">reserved</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">declare_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to declare new local operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_operator_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="k">return</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">delete_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the operator whose onnx_name is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The operator to remove was not found.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">delete_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the variable whose *onnx_name* is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The variable to remove was not found.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="n">raw_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span><span class="o">.</span><span class="n">raw_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_allowed_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
                        <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">return</span> <span class="p">{}</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">][</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;conv&#39;</span><span class="p">][</span><span class="n">alias</span><span class="p">]</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">get_allowed_options</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">allowed</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
            <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an option, for example,</span>
<span class="sd">        ``add_options(id(clr), {&#39;raw_scores&#39;: True})``</span>
<span class="sd">        tells the converter associated to ``clr`` to</span>
<span class="sd">        use raw score instead of probabilities.</span>

<span class="sd">        :param model_id: class or ``id(instance)``</span>
<span class="sd">        :param options: dictionary with the new values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">model_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns additional options for a model.</span>
<span class="sd">        It first looks by class then by id (``id(model)``).</span>
<span class="sd">        :param model: model being converted</span>
<span class="sd">        :param default_values: default options (it is modified by</span>
<span class="sd">                               the function)</span>
<span class="sd">        :param fail: fails if option it not found</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_build_options</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">default_values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_allowed_options</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">),</span>
            <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds instances on :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;` and</span>
<span class="sd">    :class:`SklearnModelContainer &lt;skl2onnx.common._container.SklearnModelContainer&gt;`.</span>
<span class="sd">    These are filled by the converters while a pipeline is being converted.</span>
<span class="sd">    When all converters were called, method</span>
<span class="sd">    :meth:`Topology.compile &lt;skl2onnx.common._topology.Topology.compile&gt;`</span>
<span class="sd">    must be called to convert the topological graph into *ONNX* graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reserved_variable_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reserved_operator_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_conversion_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a *Topology* object, which is an intermediate</span>
<span class="sd">        representation of a computational graph.</span>

<span class="sd">        :param model: RawModelContainer object or one of its derived</span>
<span class="sd">                      classes. It contains the original model.</span>
<span class="sd">        :param default_batch_size: batch_size prepend to scalar and</span>
<span class="sd">                                   array types from CoreML. It&#39;s usually</span>
<span class="sd">                                   1 or None.</span>
<span class="sd">        :param initial_types: A list providing some types for some</span>
<span class="sd">                              root variables.</span>
<span class="sd">        Each element is a tuple of a variable name and a type defined</span>
<span class="sd">        in *data_types.py*.</span>
<span class="sd">        :param reserved_variable_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a variable</span>
<span class="sd">                                        name</span>
<span class="sd">        :param reserved_operator_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a operator</span>
<span class="sd">                                        name</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying the</span>
<span class="sd">                                        user customized shape calculator</span>
<span class="sd">        :param registered_models: registered models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">reserved_variable_names</span>
            <span class="k">if</span> <span class="n">reserved_variable_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">reserved_operator_names</span>
            <span class="k">if</span> <span class="n">reserved_operator_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span> <span class="o">=</span> <span class="n">initial_types</span> <span class="k">if</span> <span class="n">initial_types</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_batch_size</span> <span class="o">=</span> <span class="n">default_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_conversion_functions</span> <span class="k">if</span> <span class="n">custom_conversion_functions</span> <span class="k">else</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_shape_calculators</span> <span class="k">if</span> <span class="n">custom_shape_calculators</span> <span class="k">else</span> <span class="p">{})</span>

        <span class="c1"># This attribute is used in optimizing the graph structure. If</span>
        <span class="c1"># root_names is not empty, only the variables specified will be</span>
        <span class="c1"># treated as the roots (i.e., set is_fed to True in the</span>
        <span class="c1"># beginning of a graph evaluation) of the graph. Specifying all</span>
        <span class="c1"># root variables in this list and leaving it empty are</span>
        <span class="c1"># equivalent. This attribute directly affects</span>
        <span class="c1"># _initialize_graph_status_for_traversing function and</span>
        <span class="c1"># indirectly affects _infer_all_shapes and _prune functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_conversion_functions must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_shape_calculators must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>

        <span class="c1"># A map of local overwritten model aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_model_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">)</span>
                           <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">all_model_types</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mtype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias</span>

        <span class="c1"># Registered models</span>
        <span class="k">if</span> <span class="n">registered_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">existing_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce an unique string based on the seed</span>
<span class="sd">        :param seed: a string</span>
<span class="sd">        :param existing_names: a set containing strings which cannot be</span>
<span class="sd">                               produced</span>
<span class="sd">        :return: a string similar to the seed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Name seed must be a non-empty string.&#39;</span><span class="p">)</span>

        <span class="c1"># Make the seed meet C-style naming convention</span>
        <span class="c1"># Only alphabets and numbers are allowed</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^0-9a-zA-Z]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="c1"># The first symbol cannot be a number</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[0-9]&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">seed</span>

        <span class="c1"># If seed has never been seen, we return it as it is. Otherwise,</span>
        <span class="c1"># we will append an number to make it unique.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">get_unique_scope_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;`</span>
<span class="sd">        and appends it to the list of existing scopes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_scope_name</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="n">parent_scopes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">unordered_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">unordered_variable_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">topological_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an iterator of all operators in Topology object.</span>
<span class="sd">        Operators may be produced in a topological order. If you want to</span>
<span class="sd">        simply go though all operators without considering their</span>
<span class="sd">        topological structure, please use another function,</span>
<span class="sd">        unordered_operator_iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;tensorToProbabilityMap&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;tensorToLabel&#39;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
                      <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">(),</span>
                                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">priorities</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
                                   <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">priorities</span> <span class="k">else</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;operator.inputs must be a list not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)))</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">):</span>
                    <span class="c1"># Check if over-writing problem occurs (i.e., multiple</span>
                    <span class="c1"># operators produce results on one variable).</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="c1"># Throw an error if this variable has been treated as</span>
                        <span class="c1"># an output somewhere</span>
                        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                            <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;--DEBUG-INFO--&quot;</span><span class="p">]</span>
                            <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;self.variable_name_set=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span><span class="p">)))</span>
                            <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;self.operator_name_set=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span><span class="p">)))</span>
                            <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                                <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span>
                                    <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_fed=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                        <span class="nb">getattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;is_fed&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">var</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_evaluated=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                        <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;is_evaluated&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">op</span><span class="p">))</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                <span class="s2">&quot;A variable is already assigned (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                                <span class="s2">&quot;for operator &#39;</span><span class="si">{}</span><span class="s2">&#39; (name=&#39;</span><span class="si">{}</span><span class="s2">&#39;). This &quot;</span>
                                <span class="s2">&quot;may still happen if a converter is a &quot;</span>
                                <span class="s2">&quot;combination of sub-estimators and one &quot;</span>
                                <span class="s2">&quot;of them is producing this output. &quot;</span>
                                <span class="s2">&quot;In that case, an identity node must be &quot;</span>
                                <span class="s2">&quot;added.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                                    <span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span>
                                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">add</span><span class="p">)))</span>
                        <span class="c1"># Mark this variable as filled</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Make this operator as handled</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># Send out an operator</span>
                    <span class="k">yield</span> <span class="n">operator</span>

                    <span class="c1"># This step may create new nodes if the</span>
                    <span class="c1"># the converter is called while looping on</span>
                    <span class="c1"># the nodes. The outputs of an operator</span>
                    <span class="c1"># are not necessary the inputs of the next</span>
                    <span class="c1"># one and but can processed by other ONNX nodes</span>
                    <span class="c1"># inserted in the container. As a result, some</span>
                    <span class="c1"># variables never have is_fed set to True which</span>
                    <span class="c1"># is updated now unless they are an operator</span>
                    <span class="c1"># output.</span>
                    <span class="n">known_outputs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;onnx_name&#39;</span><span class="p">):</span>
                                <span class="n">known_outputs</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">known_outputs</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">known_outputs</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">update</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="ow">and</span>
                                  <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span>
                                  <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                            <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># After scanning through the whole computational graph, at</span>
            <span class="c1"># least one operator should be evaluated. If not, we need</span>
            <span class="c1"># to terminate this procedure to avoid dead lock.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_evaluation_happened</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_check_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to check if the parsed model is</span>
<span class="sd">        proper. Currently, it only checks if isolated variable and</span>
<span class="sd">        isolated operator exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect all variable names and operator names</span>
        <span class="n">unused_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">unused_operators</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="n">unused_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="n">unused_operators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an input, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an output, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated variables exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_variables</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_operators</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated operators exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_operators</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_graph_status_for_traversing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the status of all variables and operators for</span>
<span class="sd">        traversing the underline graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In the beginning, we set is_root and is_leaf true. For is_fed,</span>
        <span class="c1"># we have two different behaviors depending on whether</span>
        <span class="c1"># root_names is empty.</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="c1"># If root_names is set, we only set those variable to be</span>
            <span class="c1"># fed. Otherwise, all roots would be fed.</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="ow">and</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span>
                               <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Then, we flip some flags by applying some simple rules so</span>
        <span class="c1"># that only</span>
        <span class="c1">#   1. all roots get is_root=True and is_fed=True</span>
        <span class="c1">#   2. all leaves get is_leaf=True</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># All operators are not processed in the beginning</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># Output cannot be fed before graph traversing</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># If the variable is an output of one operator,</span>
                <span class="c1"># it must not be a root</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># If the variable is an input of one operator,</span>
                <span class="c1"># it must not be a leaf</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_infer_all_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer all variables&#39; shapes in the computational graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Deliver user-specified types to root variables</span>
        <span class="k">for</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">initial_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span><span class="p">:</span>
            <span class="c1"># Check all variables declared using raw_name in</span>
            <span class="c1"># the whole graph</span>
            <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="c1"># Skip scopes without having the considered variable</span>
                <span class="c1"># name</span>
                <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Assign initial_type to all variables declared using</span>
                <span class="c1"># raw_name</span>
                <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Assign type to the root; existing type</span>
                        <span class="c1"># produced by parser may be overwritten</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">initial_type</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="c1"># overwritten operator.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">mtype</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_shape_calculator&quot;</span><span class="p">):</span>
                <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_shape_calculator</span><span class="p">()</span>
                <span class="n">shape_calc</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">infer_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_resolve_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge variables connected by identity operator to reduce the</span>
<span class="sd">        number of redundant variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;identity&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
                <span class="k">continue</span>

            <span class="c1"># Replace the output variable with the input variable everywhere</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">duplicate</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">another_scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">another_operator</span> <span class="ow">in</span> <span class="n">another_scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">onnx_name</span>
                                <span class="o">!=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">original</span>

            <span class="c1"># When original variable&#39;s documentation string or</span>
            <span class="c1"># denotation is empty but duplicate&#39;s is not, we copy that</span>
            <span class="c1"># field to the original variable to avoid information loss.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span><span class="p">:</span>
                <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="c1"># Merge the channel denotations if available in both</span>
                    <span class="c1"># the original and the duplicate</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Sometime, shapes of duplicates are different. We try</span>
                <span class="c1"># to replace the original variable&#39;s unknown dimensions</span>
                <span class="c1"># as many as possible because we will get rid of the</span>
                <span class="c1"># duplicate.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Because we&#39;re iterating through the topology, we cannot</span>
            <span class="c1"># delete any operator or variable. Otherwise, the traversing</span>
            <span class="c1"># function may be broken. We will delete those abandoned</span>
            <span class="c1"># ones later.</span>
            <span class="n">duplicate</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Find out who is going to be abandoned</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>

            <span class="c1"># Remove abandoned operators</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Remove abandoned variables</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fix_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to adjust graph inputs</span>
<span class="sd">        (i.e., roots) before doing shape inference</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Identify roots of a graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Scan through all operators and adjust their variables&#39; shapes</span>
        <span class="c1"># if needed</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># Rule 1 (CoreML):</span>
            <span class="c1"># Some operator in CoreML only accepts 4-D tensors but</span>
            <span class="c1"># their protobuf models might specify a 2-D one.</span>
            <span class="c1"># We fix this problem here.</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;concat&#39;</span><span class="p">,</span> <span class="s1">&#39;convolution&#39;</span><span class="p">,</span> <span class="s1">&#39;crop&#39;</span><span class="p">,</span> <span class="s1">&#39;flatten&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;scalerPreprocessor&#39;</span><span class="p">,</span> <span class="s1">&#39;lrn&#39;</span><span class="p">,</span> <span class="s1">&#39;meanImagePreprocessor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;padding&#39;</span><span class="p">,</span> <span class="s1">&#39;permute&#39;</span><span class="p">,</span> <span class="s1">&#39;pooling&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;reorganizeData&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="s1">&#39;upsample&#39;</span><span class="p">]:</span>
                <span class="c1"># We only adjust inputs because outputs will be</span>
                <span class="c1"># automatically fixed at our shape inference stage</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Convert [N, C] to [N, C, 1, 1] while</span>
                        <span class="c1"># [N, C, H, W] is unchanged</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                            <span class="mi">4</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Conduct a dummy evaluation of this topology. It may set all</span>
        <span class="c1"># reachable operators evaluated and all reachable variables fed.</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Remove unused operators</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
                    <span class="n">abandoned_operator_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

            <span class="c1"># Remove unused variables</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                    <span class="n">abandoned_variable_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

<div class="viewcode-block" id="Topology.compile"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function aims at giving every operator enough information</span>
<span class="sd">        so that all operator conversions can happen independently. We</span>
<span class="sd">        also want to check, fix, and simplify the network structure</span>
<span class="sd">        here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_shapes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infer_all_types</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_structure</span><span class="p">()</span></div></div>


<span class="k">def</span> <span class="nf">convert_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">doc_string</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">,</span>
                     <span class="n">channel_first_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_identity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to convert our Topology object defined in</span>
<span class="sd">    _parser.py into a ONNX model (type: ModelProto).</span>
<span class="sd">    :param topology: The Topology object we are going to convert</span>
<span class="sd">    :param model_name: GraphProto&#39;s name. Let &quot;model&quot; denote the</span>
<span class="sd">                       returned model. The string &quot;model_name&quot; would be</span>
<span class="sd">                       assigned to &quot;model.graph.name.&quot;</span>
<span class="sd">    :param doc_string: A string attached to the produced model</span>
<span class="sd">    :param target_opset: number or dictionary,</span>
<span class="sd">        for example, 7 for ONNX 1.2, and 8 for ONNX 1.3,</span>
<span class="sd">        a dictionary is used to indicate different opset for</span>
<span class="sd">        different domains</span>
<span class="sd">    :param options: see :ref:`l-conv-options`</span>
<span class="sd">    :param remove_identity: removes identity nodes</span>
<span class="sd">    include &#39;1.1.2&#39;, &#39;1.2&#39;, and so on.</span>
<span class="sd">    :return: a ONNX ModelProto</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_opset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_opset</span> <span class="o">=</span> <span class="n">get_latest_tested_opset_version</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">get_latest_tested_opset_version</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_opset_number_from_onnx</span><span class="p">():</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;version of the installed onnx package. See &quot;</span>
            <span class="s2">&quot;https://github.com/onnx/onnx/blob/master/docs/&quot;</span>
            <span class="s2">&quot;Versioning.md#released-versions&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_latest_tested_opset_version</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;the latest tested version&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">onnx_target_opset</span><span class="p">,</span>
                <span class="n">get_latest_tested_opset_version</span><span class="p">()))</span>

    <span class="n">topology</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">ModelComponentContainer</span><span class="p">(</span>
        <span class="n">target_opset</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
        <span class="n">registered_models</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">registered_models</span><span class="p">,</span>
        <span class="n">white_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_white_op</span><span class="p">,</span>
        <span class="n">black_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_black_op</span><span class="p">)</span>

    <span class="c1"># Put roots and leaves as ONNX&#39;s model into buffers. They will be</span>
    <span class="c1"># added into ModelComponentContainer later.</span>
    <span class="n">tensor_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tensor_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="c1"># Add roots the graph according to their order in the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nhwc_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">channel_first_inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_first_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="c1"># Check input naming convention</span>
        <span class="n">input_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">input_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="ow">not</span> <span class="n">input_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_inputs</span><span class="p">:</span>
            <span class="c1"># type: Variable</span>
            <span class="n">onnx_input</span> <span class="o">=</span> <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:0&#39;</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span><span class="p">)):</span>
                <span class="n">nhwc_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_input</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">onnx_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some input names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_inputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">other_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Add leaves the graph according to their order in</span>
    <span class="c1"># the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="c1"># Check output naming convention</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">output_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">output_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">tensor_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some output names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">other_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Traverse the graph from roots to leaves</span>
    <span class="c1"># This loop could eventually be parallelized.</span>
    <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">scope</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span>
                     <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">operator</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_converter&quot;</span><span class="p">):</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_converter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the selected operator into some ONNX objects and</span>
            <span class="c1"># save them into the container</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingConverter</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to find converter for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; type &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;. You may raise an issue at &quot;</span>
                    <span class="s2">&quot;https://github.com/onnx/sklearn-onnx/issues.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                              <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;raw_model&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))))</span>
        <span class="n">container</span><span class="o">.</span><span class="n">validate_options</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="n">conv</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="n">container</span><span class="o">.</span><span class="n">ensure_topological_order</span><span class="p">()</span>

    <span class="c1"># Create a graph from its main components</span>
    <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_onnx</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1"># When calling ModelComponentContainer&#39;s add_initializer(...),</span>
        <span class="c1"># nothing is added into the input list. However, for ONNX target</span>
        <span class="c1"># opset &lt; 9, initializers should also be a part of model&#39;s</span>
        <span class="c1"># (GraphProto) inputs. Thus, we create ValueInfoProto objects</span>
        <span class="c1"># from initializers (type: TensorProto) directly and then add</span>
        <span class="c1"># them into model&#39;s input list.</span>
        <span class="n">extra_inputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ValueInfoProto list of the initializers</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">:</span>
            <span class="c1"># Sometimes (especially when creating optional input values</span>
            <span class="c1"># such as RNN&#39;s initial hidden state), an initializer is also</span>
            <span class="c1"># one of the original model&#39;s input, so it has been added into</span>
            <span class="c1"># the container&#39;s input list. If this is the case, we need to</span>
            <span class="c1"># skip one iteration to avoid duplicated inputs.</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">value_info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">value_info</span> <span class="ow">in</span>
                               <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Initializers are always tensors so we can just call</span>
            <span class="c1"># make_tensor_value_info(...).</span>
            <span class="n">value_info</span> <span class="o">=</span> <span class="n">make_tensor_value_info</span><span class="p">(</span>
                <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">extra_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_info</span><span class="p">)</span>

        <span class="c1"># Before ONNX opset 9, initializers were needed to be passed in</span>
        <span class="c1"># with inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">extra_inputs</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># In ONNX opset 9 and above, initializers are included as</span>
        <span class="c1"># operator inputs and therefore do not need to be passed as</span>
        <span class="c1"># extra_inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span>
            <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>

    <span class="c1"># Add extra information related to the graph</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create model</span>
    <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">make_model</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Update domain version</span>
    <span class="n">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">)</span>

    <span class="c1"># Add extra information</span>
    <span class="n">opv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span>
              <span class="n">_get_main_opset_version</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span> <span class="ow">or</span> <span class="n">onnx_target_opset</span><span class="p">)</span>
    <span class="n">irv</span> <span class="o">=</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">opv</span><span class="p">,</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">IR_VERSION</span><span class="p">)</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">irv</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_name</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">model_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_model_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

    <span class="c1"># Removes many identity nodes,</span>
    <span class="c1"># the converter may introduct identity nodes</span>
    <span class="c1"># after a zipmap operator and onnx &lt;= 1.7 does not</span>
    <span class="c1"># support that. It does not use onnxconverter-common</span>
    <span class="c1"># as the optimizer only support opset &gt;= 9.</span>
    <span class="k">if</span> <span class="n">remove_identity</span><span class="p">:</span>
        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx_remove_node_identity</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">onnx_model</span>


<span class="k">def</span> <span class="nf">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">):</span>
    <span class="c1"># Merge operator sets for the same domain, the largest version</span>
    <span class="c1"># number would be kept</span>
    <span class="n">purified_operator_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">node_domain_version_pair_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">],</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Fill operator sets</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">op_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Overwrite the default operator set created by</span>
            <span class="c1"># make_model(...)</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Just create one ONNX element in opset_import</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">op_domain</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;The specified opset </span><span class="si">%d</span><span class="s1"> is too low to convert &#39;</span>
                <span class="s1">&#39;this model, which requires at least opset &#39;</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">),</span>
                    <span class="n">op_version</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_get_main_opset_version</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the main opset version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mld</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">:</span>
            <span class="n">mld</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
    <span class="k">if</span> <span class="n">mld</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OPSET_ML_TO_OPSET</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mld</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo_main.png" alt="Logo"/>
            </a></p><h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation index</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../skl2onnx.html">skl2onnx</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2018-2021, Microsoft.
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.1.0.
  </div>
  
  </body>
</html>