
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>skl2onnx.common._topology &#8212; sklearn-onnx 1.10.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/readable.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery-rendered-html.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sklearn-onnx 1.10.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../skl2onnx.html" accesskey="U">skl2onnx</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">skl2onnx.common._topology</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for skl2onnx.common._topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-License-Identifier: Apache-2.0</span>


<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">onnx</span> <span class="kn">import</span> <span class="n">onnx_pb</span> <span class="k">as</span> <span class="n">onnx_proto</span>
<span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa</span>
    <span class="n">DataType</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>
    <span class="n">FloatType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span>
    <span class="n">DictionaryType</span><span class="p">,</span> <span class="n">FloatTensorType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">Int64TensorType</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">StringTensorType</span><span class="p">,</span> <span class="n">DoubleTensorType</span><span class="p">,</span>
    <span class="n">Int32TensorType</span><span class="p">,</span> <span class="n">BooleanTensorType</span><span class="p">,</span>
    <span class="n">DoubleTensorType</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Int8TensorType</span><span class="p">,</span> <span class="n">UInt8TensorType</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Int8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">UInt8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_opset_number_from_onnx</span><span class="p">,</span>
    <span class="n">get_latest_tested_opset_version</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..proto.onnx_helper_modified</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">make_graph</span><span class="p">,</span> <span class="n">make_model</span><span class="p">,</span> <span class="n">make_tensor_value_info</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_registration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">MissingShapeCalculator</span><span class="p">,</span> <span class="n">MissingConverter</span>
<span class="kn">from</span> <span class="nn">._container</span> <span class="kn">import</span> <span class="n">ModelComponentContainer</span><span class="p">,</span> <span class="n">_build_options</span>
<span class="kn">from</span> <span class="nn">.onnx_optimisation_identity</span> <span class="kn">import</span> <span class="n">onnx_remove_node_identity</span>

<span class="n">type_fct</span> <span class="o">=</span> <span class="nb">type</span>


<span class="k">def</span> <span class="nf">_default_OPSET_TO_IR_VERSION</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="mi">13</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">8</span>
    <span class="p">}</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.topology</span> <span class="kn">import</span> <span class="n">OPSET_TO_IR_VERSION</span>
    <span class="k">assert</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
    <span class="n">OPSET_TO_IR_VERSION</span> <span class="o">=</span> <span class="n">_default_OPSET_TO_IR_VERSION</span><span class="p">()</span>

<span class="n">OPSET_ML_TO_OPSET</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">15</span><span class="p">}</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;skl2onnx&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable which holds any data defined</span>
<span class="sd">    from *ONNX* types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_UNIQUE_NUMBER_</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param raw_name: A string indicating the variable&#39;s name in the</span>
<span class="sd">                         original model. Usually, it&#39;s the seed string</span>
<span class="sd">                         used to created its ONNX name (i.e., the</span>
<span class="sd">                         field *onnx_name* below).</span>
<span class="sd">        :param onnx_name: A string indicating the variable&#39;s name in</span>
<span class="sd">                          the converted model</span>
<span class="sd">        :param scope: A string. It&#39;s the name of the scope where this</span>
<span class="sd">                      variable is declared</span>
<span class="sd">        :param type: A type object defined in .common.data_types.py;</span>
<span class="sd">                     e.g., FloatTensorType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;raw_name must be a string not &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">raw_name</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected type for variable raw_name=</span><span class="si">%r</span><span class="s2">, type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">onnx_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">onnx_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;u(&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">onnx_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="n">onnx_name0</span> <span class="o">=</span> <span class="n">onnx_name</span>
                <span class="k">if</span> <span class="n">scope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">onnx_name</span> <span class="o">=</span> <span class="s2">&quot;UU</span><span class="si">%03d</span><span class="s2">UU&quot;</span> <span class="o">%</span> <span class="n">Variable</span><span class="o">.</span><span class="n">_UNIQUE_NUMBER_</span>
                    <span class="n">Variable</span><span class="o">.</span><span class="n">_UNIQUE_NUMBER_</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">onnx_name</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;[Var] rename raw_name=</span><span class="si">%r</span><span class="s1">, onnx_name=</span><span class="si">%r</span><span class="s1"> into </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name0</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;onnx_name must be a string not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">onnx_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">not_none</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shape</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;A variable cannot be empty, raw_name=</span><span class="si">%r</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;onnx_name=</span><span class="si">%r</span><span class="s2">, shape=</span><span class="si">%r</span><span class="s2">, type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span> <span class="o">=</span> <span class="n">raw_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The following fields are bool variables used in parsing and</span>
        <span class="c1"># compiling stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">DataType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;shape must be a DataType not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be a tuple or a list not &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_fct</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;shape must contains integers not </span><span class="si">%r</span><span class="s2"> (type=</span><span class="si">%r</span><span class="s2">).&quot;</span>
                        <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] +</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># links to operators using those variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators_outputs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators_inputs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Unexpected type </span><span class="si">%r</span><span class="s2"> for shape </span><span class="si">%r</span><span class="s2">.&quot;</span>
                        <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_fed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span>

    <span class="k">def</span> <span class="nf">init_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_fed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_fed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_fed</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update is_fed=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">, parent=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">is_fed</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span> <span class="o">=</span> <span class="n">is_fed</span>
        <span class="k">if</span> <span class="n">is_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_root</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update is_root=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">is_root</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span> <span class="o">=</span> <span class="n">is_root</span>
        <span class="k">if</span> <span class="n">is_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_leaf</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update is_leaf=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">is_leaf</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span> <span class="o">=</span> <span class="n">is_leaf</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;onnx_name&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You must use method set_onnx_name.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;is_fed&quot;</span><span class="p">,</span> <span class="s2">&quot;is_root&quot;</span><span class="p">,</span> <span class="s2">&quot;is_leaf&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You must use method init_status.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;scope&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_name&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;scope or raw_name cannot be changed.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Variable</span><span class="p">))</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected new type for variable </span><span class="si">%r</span><span class="s2">, new_type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update type for </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">new_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">onnx_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update onnx_name, from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1"> in </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">rename_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>

    <span class="k">def</span> <span class="nf">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;This variable is already the output of operator </span><span class="si">%r</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;It cannot be the output of </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">operator</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] set parent for </span><span class="si">%r</span><span class="s1">, parent=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">get_first_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first dimension (batch dimension) or</span>
<span class="sd">        None if not specified (shape is empty).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_second_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique variable ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Variable(&#39;</span><span class="si">{0}</span><span class="s2">&#39;, &#39;</span><span class="si">{1}</span><span class="s2">&#39;, type=</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_pb</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a data type from a protobuf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_dim</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span>
            <span class="k">if</span> <span class="s2">&quot;dim_param&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># dim_value is 0 when it is 0 or undefined</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="s2">&quot;0&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">get_dim</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">))]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Variable</span><span class="o">.</span><span class="n">from_pb</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">elem_type</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">BooleanTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">DoubleTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">StringTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int64TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int32TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">UInt8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">UInt8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">Int8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; (elem_type=</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">),</span> <span class="n">elem</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; as &quot;</span>
                                      <span class="s2">&quot;a string (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                          <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ty</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Enables expression such as `a,b = self`.&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Unreachable element at index </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_or_out</span><span class="p">):</span>
        <span class="s2">&quot;Add a link to an operator, True for output, False for input.&quot;</span>
        <span class="k">if</span> <span class="n">in_or_out</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_compatible_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">empty_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">elif</span> <span class="n">other_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other_type</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">empty_shape</span><span class="p">(</span><span class="n">other_type</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Incompatible type for variable </span><span class="si">%r</span><span class="s2"> and type </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">))</span></div>


<span class="k">class</span> <span class="nc">VariableStr</span><span class="p">(</span><span class="n">Variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable a string. This should be avoided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Variable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;u(&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Variable should be renamed as onnx_name=</span><span class="si">%r</span><span class="s2">.&quot;</span>
                <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an operator available in *ONNX*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">OperatorList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Operator equal not implemented and not needed.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input and output must be of type Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;Out&#39;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Op] add </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;In&#39;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;Out&quot;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Unexpected value for kind=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Element </span><span class="si">%d</span><span class="s2"> must be a Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span>
                <span class="s2">&quot;Setter should not be used to modify an element.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="s2">&quot;Updates element i.&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Value v must be a Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Op] </span><span class="si">%s</span><span class="s2">-change element </span><span class="si">%d</span><span class="s2"> from </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2"> in </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;onnx_name&#39;</span><span class="p">):</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param onnx_name: A unique ID, which is a string</span>
<span class="sd">        :param scope: The name of the scope where this operator is</span>
<span class="sd">                      declared. It&#39;s a string.</span>
<span class="sd">        :param type: A object which uniquely characterizes the type of</span>
<span class="sd">                     this operator. For example, it can be a string,</span>
<span class="sd">                     pooling, if this operator is associated with a</span>
<span class="sd">                     CoreML pooling layer.</span>
<span class="sd">        :param raw_operator: The original operator which defines this operator;</span>
<span class="sd">                             for example, a scikit-learn Imputer and</span>
<span class="sd">                             a CoreML Normalizer.</span>
<span class="sd">        :param target_opset: The target opset number for the converted model.</span>
<span class="sd">        :param scope_inst: :class:`Scope` instance the operator belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Parameter raw_operator must be an object not &quot;</span>
                               <span class="s2">&quot;a string &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">))</span>
        <span class="c1"># operator name in the converted model, if raw_operator</span>
        <span class="c1"># is not None, output_shapes can be guessed</span>
        <span class="c1"># from the raw model. Otherwise, it can be guessed</span>
        <span class="c1"># from the input shapes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">raw_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;In&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_inst</span> <span class="o">=</span> <span class="n">scope_inst</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Op] +</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_raw_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a shallow copy of this operator,</span>
<span class="sd">        changes the raw_operator but keeps the same inputs</span>
<span class="sd">        and outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_inst</span><span class="p">)</span>
        <span class="n">op</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">op</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="s2">&quot;MISSING OP&quot;</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># The line above fails for python 3.7</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">textop</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">textop</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="n">textop</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Operator(type=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, inputs=&#39;</span><span class="si">{2}</span><span class="s2">&#39;, &quot;</span>
                <span class="s2">&quot;outputs=&#39;</span><span class="si">{3}</span><span class="s2">&#39;, raw_operator=</span><span class="si">{4}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                    <span class="n">textop</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;outputs&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;inputs&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;In&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;outputs&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Out&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;inputs or outputs must be of type Operator.OperatorList.&quot;</span><span class="p">)</span>
            <span class="n">ioo</span> <span class="o">=</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;outputs&#39;</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ioo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_evaluated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span>

    <span class="k">def</span> <span class="nf">init_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_evaluated</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_evaluated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_evaluated</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Op] update is_evaluated=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">is_evaluated</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span> <span class="o">=</span> <span class="n">is_evaluated</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique operator ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all input variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all output variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original operator/layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span>

    <span class="k">def</span> <span class="nf">infer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke a core inference function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">shape_calc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Shape-a] </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)))</span>
        <span class="n">shape_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Shape-b] </span><span class="si">%r</span><span class="s2"> inputs=</span><span class="si">%r</span><span class="s2"> - outputs=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span></div>


<div class="viewcode-block" id="Scope"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope">[docs]</a><span class="k">class</span> <span class="nc">Scope</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Every node of an *ONNX* graph must be unique. This class holds the list</span>
<span class="sd">    of existing name for every node already defined in graph. It also</span>
<span class="sd">    provides functions to create a unique unused name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">naming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: A string, the unique ID of this scope in a</span>
<span class="sd">                     Topology object</span>
<span class="sd">        :param target_opset: The target opset number for the converted</span>
<span class="sd">                             model.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying</span>
<span class="sd">                                the user customized shape calculator</span>
<span class="sd">        :param options: see :ref:`l-conv-options`</span>
<span class="sd">        :param naming: the user may want to change the way intermediate</span>
<span class="sd">            are named, this parameter can be a string (a prefix) or a</span>
<span class="sd">            function, which signature is the following:</span>
<span class="sd">            `get_name(name, existing_names)`, the library will then</span>
<span class="sd">            check this name is unique and modify it if not</span>
<span class="sd">        :param registered_models: registered models</span>

<span class="sd">        .. versionchanged:: 1.10.0</span>
<span class="sd">            Parameter *naming* was added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="n">custom_shape_calculators</span>

        <span class="c1"># An one-to-many map from raw variable name to ONNX variable</span>
        <span class="c1"># names. It looks like</span>
        <span class="c1"># (key, value) = (raw_name, [onnx_name, onnx_name1, onnx_name2, ..., onnx_nameN]) # noqa</span>
        <span class="c1"># The last name may hide all other names in this scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local variables defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, variable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_variables</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A map of local operators defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, operator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Additional options given to converters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># Registered models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">naming</span> <span class="o">=</span> <span class="n">naming</span>

        <span class="k">if</span> <span class="n">naming</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">naming</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">naming</span> <span class="o">+</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">naming</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">),</span> <span class="n">names</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected type for parameter naming: </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">naming</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">):</span>
        <span class="s2">&quot;Returns variable with &#39;name&#39; or default value is not found.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if a variable is already registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span>

    <span class="k">def</span> <span class="nf">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape calculator for the given model type.</span>

<span class="sd">        :param model_type: model type such as *LogisticRegression*</span>
<span class="sd">        :return: alias or None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Scope.get_unique_variable_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_variable_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique variable ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter seed must be a string not </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                <span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Scope.get_unique_operator_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_operator_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_operator_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique operator ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">declare_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">missing_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function may create a new variable in this scope. If</span>
<span class="sd">        *raw_name* has been used to create other variables, the new</span>
<span class="sd">        variable will hide all other variables created using *raw_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">missing_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown type for </span><span class="si">%r</span><span class="s2"> (type=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="c1"># Get unique ID for the new variable</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>

        <span class="c1"># Create the variable</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">register_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="s2">&quot;Adds a variable to the scope.&quot;</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Variable </span><span class="si">%r</span><span class="s2"> already registered (other=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="c1"># Hide existing variables with the same raw_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">rename_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Name </span><span class="si">%r</span><span class="s2"> already in variables (</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">new_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">old_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find name </span><span class="si">%r</span><span class="s2"> in variables.&quot;</span> <span class="o">%</span> <span class="n">old_name</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Scope] update onnx_name, from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">declare_local_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `declare_local_variable`. Registers this variable</span>
<span class="sd">        as an input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_local_variable</span><span class="p">(</span>
            <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">declare_local_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">missing_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `declare_local_variable`. Registers this variable</span>
<span class="sd">        as an output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_local_variable</span><span class="p">(</span>
            <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span>
            <span class="n">missing_type</span><span class="o">=</span><span class="n">missing_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">declare_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to declare new local operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_operator_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="k">return</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">_get_allowed_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
                        <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">return</span> <span class="p">{}</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">][</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;conv&#39;</span><span class="p">][</span><span class="n">alias</span><span class="p">]</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">get_allowed_options</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">allowed</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
            <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an option, for example,</span>
<span class="sd">        ``add_options(id(clr), {&#39;raw_scores&#39;: True})``</span>
<span class="sd">        tells the converter associated to ``clr`` to</span>
<span class="sd">        use raw score instead of probabilities.</span>

<span class="sd">        :param model_id: class or ``id(instance)``</span>
<span class="sd">        :param options: dictionary with the new values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">model_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns additional options for a model.</span>
<span class="sd">        It first looks by class then by id (``id(model)``).</span>
<span class="sd">        :param model: model being converted</span>
<span class="sd">        :param default_values: default options (it is modified by</span>
<span class="sd">                               the function)</span>
<span class="sd">        :param fail: fails if option it not found</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_build_options</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">default_values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_allowed_options</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">),</span>
            <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_raw_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces every raw operator op1 by op2.</span>
<span class="sd">        The function uses `id()` to detect op1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">op1</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Scope] replace </span><span class="si">%d</span><span class="s1"> by </span><span class="si">%d</span><span class="s1"> in </span><span class="si">%r</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span> <span class="n">v</span><span class="p">))</span>
                <span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">op2</span>
                <span class="n">v</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">alias</span></div>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds instances on :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;` and</span>
<span class="sd">    :class:`SklearnModelContainer</span>
<span class="sd">    &lt;skl2onnx.common._container.SklearnModelContainer&gt;`.</span>
<span class="sd">    These are filled by the converters while a pipeline is being converted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_conversion_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a *Topology* object, which is an intermediate</span>
<span class="sd">        representation of a computational graph.</span>

<span class="sd">        :param model: RawModelContainer object or one of its derived</span>
<span class="sd">                      classes. It contains the original model.</span>
<span class="sd">        :param default_batch_size: batch_size prepend to scalar and</span>
<span class="sd">                                   array types from CoreML. It&#39;s usually</span>
<span class="sd">                                   1 or None.</span>
<span class="sd">        :param initial_types: A list providing some types for some</span>
<span class="sd">                              root variables.</span>
<span class="sd">        Each element is a tuple of a variable name and a type defined</span>
<span class="sd">        in *data_types.py*.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying the</span>
<span class="sd">                                        user customized shape calculator</span>
<span class="sd">        :param registered_models: registered models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span> <span class="o">=</span> <span class="n">initial_types</span> <span class="k">if</span> <span class="n">initial_types</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_batch_size</span> <span class="o">=</span> <span class="n">default_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_conversion_functions</span> <span class="k">if</span> <span class="n">custom_conversion_functions</span> <span class="k">else</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_shape_calculators</span> <span class="k">if</span> <span class="n">custom_shape_calculators</span> <span class="k">else</span> <span class="p">{})</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_conversion_functions must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_shape_calculators must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>

        <span class="c1"># A map of local overwritten model aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_model_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">)</span>
                           <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">all_model_types</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mtype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias</span>

        <span class="c1"># Registered models</span>
        <span class="k">if</span> <span class="n">registered_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope is allowed not </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">existing_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce an unique string based on the seed</span>
<span class="sd">        :param seed: a string</span>
<span class="sd">        :param existing_names: a set containing strings which cannot be</span>
<span class="sd">                               produced</span>
<span class="sd">        :return: a string similar to the seed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Name seed must be a non-empty string.&#39;</span><span class="p">)</span>

        <span class="c1"># Make the seed meet C-style naming convention</span>
        <span class="c1"># Only alphabets and numbers are allowed</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^0-9a-zA-Z]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="c1"># The first symbol cannot be a number</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[0-9]&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">seed</span>

        <span class="c1"># If seed has never been seen, we return it as it is. Otherwise,</span>
        <span class="c1"># we will append an number to make it unique.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">get_unique_scope_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">naming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;`</span>
<span class="sd">        and appends it to the list of existing scopes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope can be created.&quot;</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_scope_name</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="n">target_opset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">,</span>
            <span class="n">naming</span><span class="o">=</span><span class="n">naming</span><span class="p">)</span>

        <span class="c1"># Declare input variables.</span>
        <span class="c1"># They should be the inputs of the scikit-learn</span>
        <span class="c1"># model you want to convert into ONNX.</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">initial_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span><span class="p">:</span>
            <span class="n">scope</span><span class="o">.</span><span class="n">declare_local_input</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">initial_type</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">unordered_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">unordered_variable_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">call_converter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s2">&quot;Calls converter for operator *operator*.&quot;</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_converter&quot;</span><span class="p">):</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_converter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the selected operator into some ONNX objects and</span>
            <span class="c1"># save them into the container</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingConverter</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to find converter for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; type &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;. You may raise an issue at &quot;</span>
                    <span class="s2">&quot;https://github.com/onnx/sklearn-onnx/issues.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                              <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;raw_model&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))))</span>

        <span class="n">container</span><span class="o">.</span><span class="n">validate_options</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[call_converter] call converter for </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Conv] call </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">operator</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">)))</span>
        <span class="n">conv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Conv] end - </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="s2">&quot;Calls shape_calculator for operator *operator*.&quot;</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="c1"># overwritten operator.</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_shape_calculator&quot;</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;onnx_shape_calculator&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_shape_calculator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">shape_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Shape1] </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2"> (source=</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">operator</span><span class="p">,</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
                <span class="n">source</span><span class="p">))</span>
            <span class="n">shape_calc</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Shape2] call infer_types for </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">operator</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">infer_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_graph_status_for_traversing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the status of all variables and operators before</span>
<span class="sd">        traversing the graph. Only used by convert_operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope is allowed not </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">))</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected inputs.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="n">is_input</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">input_names</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="n">is_input</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_evaluated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_propagate_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">fed_variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Propagates status *is_fed* based on output variable</span>
<span class="sd">        and node added in the container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_fed</span><span class="p">]</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                    <span class="n">nodes</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">fed_variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="p">:</span>
                            <span class="n">fed_variables</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                                <span class="n">var</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls all converters and shape_calculator for existing</span>
<span class="sd">        operators. It also processes new operators created by</span>
<span class="sd">        converters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_check_operator_</span><span class="p">(</span><span class="n">operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;operator.inputs must be a Operator.OperatorList &quot;</span>
                    <span class="s2">&quot;not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;operator.outputs must be a Operator.OperatorList &quot;</span>
                    <span class="s2">&quot;not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;One input is not a Variable for operator </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="n">operator</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;One output is not a Variable for operator </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="n">operator</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_check_variable_in_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
            <span class="n">idop</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Operator </span><span class="si">%r</span><span class="s2"> not registered in the list of operators &quot;</span>
                    <span class="s2">&quot;of </span><span class="si">%r</span><span class="s2"> taking it as an input [</span><span class="se">\n</span><span class="si">%s</span><span class="s2">].&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">operator</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">))))</span>

        <span class="k">def</span> <span class="nf">_check_variable_out_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;--DEBUG-INFO--&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span>
                        <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">))</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_fed=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> - n_in=</span><span class="si">%d</span><span class="s2"> n_out=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;is_fed&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">var</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">),</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">)))</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_evaluated=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;is_evaluated&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">op</span><span class="p">))</span>
                <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; inputs=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; outputs=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--- operator producing this variable--&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;A variable is already assigned (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;for operator &#39;</span><span class="si">{}</span><span class="s2">&#39; (name=&#39;</span><span class="si">{}</span><span class="s2">&#39;). &quot;</span>
                    <span class="s2">&quot;operator.is_evaluated=</span><span class="si">{}</span><span class="s2">, inputs.is_fed=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;outputs.is_fed=</span><span class="si">{}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;This may still happen if a converter is a &quot;</span>
                    <span class="s2">&quot;combination of sub-estimators and one &quot;</span>
                    <span class="s2">&quot;of them is producing this output. &quot;</span>
                    <span class="s2">&quot;In that case, an identity node must be &quot;</span>
                    <span class="s2">&quot;added.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                        <span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">],</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">add</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] begin&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>
        <span class="n">fed_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">}</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">changes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] iteration </span><span class="si">%d</span><span class="s2"> - n_vars=</span><span class="si">%d</span><span class="s2"> &quot;</span>
                      <span class="s2">&quot;n_ops=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fed_variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
                <span class="n">_check_operator_</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                        <span class="n">fed_variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">):</span>

                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="n">_check_variable_in_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="n">_check_variable_out_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">call_shape_calculator</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">call_converter</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

                    <span class="c1"># If an operator contains a sequence of operators,</span>
                    <span class="c1"># output variables are not necessarily known at this stage.</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_evaluated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span>
                               <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">):</span>
                            <span class="n">variable</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">fed_variables</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                    <span class="n">fed_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span>
                         <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_status</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">fed_variables</span><span class="p">)</span>
                    <span class="c1"># unfed some variables (it happens when a node</span>
                    <span class="c1"># shares an output with another node)</span>
                    <span class="n">rem</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;operators_outputs_&#39;</span><span class="p">):</span>
                            <span class="c1"># initializer</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">is_evaluated</span>
                               <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">):</span>
                            <span class="n">rem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rem</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">fed_variables</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">fed_variables</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span>
                    <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] end iter: </span><span class="si">%d</span><span class="s2"> - n_vars=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fed_variables</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] end.&quot;</span><span class="p">)</span>

        <span class="c1"># Last verification.</span>
        <span class="n">not_evaluated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
                <span class="n">not_evaluated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_evaluated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;---VARS---&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;is_fed=</span><span class="si">%r</span><span class="s2"> is_leaf=</span><span class="si">%r</span><span class="s2"> is_root=</span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2"> - n_in=</span><span class="si">%d</span><span class="s2"> n_out=</span><span class="si">%d</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">is_fed</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">is_root</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">),</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">)))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;---OPERATORS---&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;is_eval=</span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;---NODES---&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Not all operators have been evaluated. A variable name &quot;</span>
                <span class="s2">&quot;is probably misspelled.</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

        <span class="c1"># Input and output</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">()</span>
                      <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_root</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">()</span>
                   <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">]</span>

        <span class="c1"># The function checks that for output variable,</span>
        <span class="c1"># raw_name equal onnx_name. It swaps names if it is not the case.</span>
        <span class="n">to_swap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">raw_name</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">:</span>
                <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_swap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">swaped</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">to_swap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span> <span class="ow">in</span> <span class="n">swaped</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">swaped</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] </span><span class="si">%r</span><span class="s2"> &lt;-&gt; </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">))</span>
                <span class="n">old_name</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">container</span><span class="o">.</span><span class="n">swap_names</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s1">&#39;[Topo] unable to swap </span><span class="si">%r</span><span class="s1"> and </span><span class="si">%r</span><span class="s1"> (</span><span class="si">%r</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">set_onnx_name</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">==</span> <span class="n">new_name</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">set_onnx_name</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.convert_topology">[docs]</a><span class="k">def</span> <span class="nf">convert_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">doc_string</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">,</span>
                     <span class="n">channel_first_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_identity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to convert our Topology object defined in</span>
<span class="sd">    _parser.py into a ONNX model (type: ModelProto).</span>

<span class="sd">    :param topology: The Topology object we are going to convert</span>
<span class="sd">    :param model_name: GraphProto&#39;s name. Let &quot;model&quot; denote the</span>
<span class="sd">        returned model. The string &quot;model_name&quot; would be</span>
<span class="sd">        assigned to &quot;model.graph.name.&quot;</span>
<span class="sd">    :param doc_string: A string attached to the produced model</span>
<span class="sd">    :param target_opset: number or dictionary,</span>
<span class="sd">        for example, 7 for ONNX 1.2, and 8 for ONNX 1.3,</span>
<span class="sd">        a dictionary is used to indicate different opset for</span>
<span class="sd">        different domains</span>
<span class="sd">    :param options: see :ref:`l-conv-options`</span>
<span class="sd">    :param remove_identity: removes identity nodes</span>
<span class="sd">        include &#39;1.1.2&#39;, &#39;1.2&#39;, and so on.</span>
<span class="sd">    :param verbose: displays information while converting</span>
<span class="sd">    :return: a ONNX ModelProto</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_opset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_opset</span> <span class="o">=</span> <span class="n">get_latest_tested_opset_version</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">get_latest_tested_opset_version</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_opset_number_from_onnx</span><span class="p">():</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;version of the installed onnx package. See &quot;</span>
            <span class="s2">&quot;https://github.com/onnx/onnx/blob/master/docs/&quot;</span>
            <span class="s2">&quot;Versioning.md#released-versions&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_latest_tested_opset_version</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;the latest tested version&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">onnx_target_opset</span><span class="p">,</span>
                <span class="n">get_latest_tested_opset_version</span><span class="p">()))</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">ModelComponentContainer</span><span class="p">(</span>
        <span class="n">target_opset</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
        <span class="n">registered_models</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">registered_models</span><span class="p">,</span>
        <span class="n">white_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_white_op</span><span class="p">,</span>
        <span class="n">black_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_black_op</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># Traverse the graph from roots to leaves</span>
    <span class="c1"># This loop could eventually be parallelized.</span>
    <span class="n">topology</span><span class="o">.</span><span class="n">convert_operators</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">container</span><span class="o">.</span><span class="n">ensure_topological_order</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected inputs after conversion.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected outputs after conversion.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---NODES---&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>

    <span class="c1"># Create a graph from its main components</span>
    <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_onnx</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1"># When calling ModelComponentContainer&#39;s add_initializer(...),</span>
        <span class="c1"># nothing is added into the input list. However, for ONNX target</span>
        <span class="c1"># opset &lt; 9, initializers should also be a part of model&#39;s</span>
        <span class="c1"># (GraphProto) inputs. Thus, we create ValueInfoProto objects</span>
        <span class="c1"># from initializers (type: TensorProto) directly and then add</span>
        <span class="c1"># them into model&#39;s input list.</span>
        <span class="n">extra_inputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ValueInfoProto list of the initializers</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">:</span>
            <span class="c1"># Sometimes (especially when creating optional input values</span>
            <span class="c1"># such as RNN&#39;s initial hidden state), an initializer is also</span>
            <span class="c1"># one of the original model&#39;s input, so it has been added into</span>
            <span class="c1"># the container&#39;s input list. If this is the case, we need to</span>
            <span class="c1"># skip one iteration to avoid duplicated inputs.</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">value_info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">value_info</span> <span class="ow">in</span>
                               <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Initializers are always tensors so we can just call</span>
            <span class="c1"># make_tensor_value_info(...).</span>
            <span class="n">value_info</span> <span class="o">=</span> <span class="n">make_tensor_value_info</span><span class="p">(</span>
                <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">extra_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_info</span><span class="p">)</span>

        <span class="c1"># Before ONNX opset 9, initializers were needed to be passed in</span>
        <span class="c1"># with inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">extra_inputs</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># In ONNX opset 9 and above, initializers are included as</span>
        <span class="c1"># operator inputs and therefore do not need to be passed as</span>
        <span class="c1"># extra_inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span>
            <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>

    <span class="c1"># Add extra information related to the graph</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create model</span>
    <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">make_model</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Update domain version</span>
    <span class="n">opv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span>
              <span class="n">_get_main_opset_version</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span> <span class="ow">or</span> <span class="n">onnx_target_opset</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
        <span class="c1"># Main opset was not added. Doing it here.</span>
        <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">opv</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[convert_topology] +opset: name=</span><span class="si">%r</span><span class="s1">, version=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">opv</span><span class="p">))</span>

    <span class="c1"># Add extra information</span>
    <span class="n">irv</span> <span class="o">=</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">opv</span><span class="p">,</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">IR_VERSION</span><span class="p">)</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">irv</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_name</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">model_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_model_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

    <span class="c1"># Removes many identity nodes,</span>
    <span class="c1"># the converter may introduct identity nodes</span>
    <span class="c1"># after a zipmap operator and onnx &lt;= 1.7 does not</span>
    <span class="c1"># support that. It does not use onnxconverter-common</span>
    <span class="c1"># as the optimizer only support opset &gt;= 9.</span>
    <span class="k">if</span> <span class="n">remove_identity</span><span class="p">:</span>
        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx_remove_node_identity</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">onnx_model</span></div>


<span class="k">def</span> <span class="nf">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># Merge operator sets for the same domain, the largest version</span>
    <span class="c1"># number would be kept</span>
    <span class="n">purified_operator_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">node_domain_version_pair_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">],</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Fill operator sets</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">op_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Overwrite the default operator set created by</span>
            <span class="c1"># make_model(...)</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Just create one ONNX element in opset_import</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[_update_domain_version] +opset </span><span class="si">%d</span><span class="s1">: name=</span><span class="si">%r</span><span class="s1">, version=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span><span class="p">))</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">op_domain</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;The specified opset </span><span class="si">%d</span><span class="s1"> is too low to convert &#39;</span>
                <span class="s1">&#39;this model, which requires at least opset &#39;</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">),</span>
                    <span class="n">op_version</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">purified_operator_set</span>


<span class="k">def</span> <span class="nf">_get_main_opset_version</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the main opset version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mld</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">:</span>
            <span class="n">mld</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
    <span class="k">if</span> <span class="n">mld</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OPSET_ML_TO_OPSET</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mld</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo_main.png" alt="Logo"/>
            </a></p><h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation index</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../skl2onnx.html">skl2onnx</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2018-2021, Microsoft.
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.
  </div>
  
  </body>
</html>