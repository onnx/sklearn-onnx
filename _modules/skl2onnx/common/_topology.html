
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>skl2onnx.common._topology &#8212; sklearn-onnx 1.6.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/readable.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">sklearn-onnx 1.6.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../skl2onnx.html" accesskey="U">skl2onnx</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for skl2onnx.common._topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># Copyright (c) Microsoft Corporation. All rights reserved.</span>
<span class="c1"># Licensed under the MIT License. See License.txt in the project root for</span>
<span class="c1"># license information.</span>
<span class="c1"># --------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">onnx</span> <span class="k">import</span> <span class="n">onnx_pb</span> <span class="k">as</span> <span class="n">onnx_proto</span>
<span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="k">import</span> <span class="p">(</span>  <span class="c1"># noqa</span>
    <span class="n">DataType</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>
    <span class="n">FloatType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span>
    <span class="n">DictionaryType</span><span class="p">,</span> <span class="n">FloatTensorType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">Int64TensorType</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">StringTensorType</span><span class="p">,</span> <span class="n">DoubleTensorType</span><span class="p">,</span>
    <span class="n">Int32TensorType</span><span class="p">,</span> <span class="n">BooleanTensorType</span><span class="p">,</span>
    <span class="n">DoubleTensorType</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="k">import</span> <span class="n">get_opset_number_from_onnx</span>
<span class="kn">from</span> <span class="nn">..proto.onnx_helper_modified</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">make_graph</span><span class="p">,</span> <span class="n">make_model</span><span class="p">,</span> <span class="n">make_tensor_value_info</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_registration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="k">import</span> <span class="n">MissingShapeCalculator</span><span class="p">,</span> <span class="n">MissingConverter</span>
<span class="kn">from</span> <span class="nn">._container</span> <span class="k">import</span> <span class="n">ModelComponentContainer</span><span class="p">,</span> <span class="n">_build_options</span>
<span class="kn">from</span> <span class="nn">.interface</span> <span class="k">import</span> <span class="n">OperatorBase</span>
<span class="n">type_fct</span> <span class="o">=</span> <span class="nb">type</span>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable which holds any data defined</span>
<span class="sd">    from *ONNX* types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param raw_name: A string indicating the variable&#39;s name in the</span>
<span class="sd">                         original model. Usually, it&#39;s the seed string</span>
<span class="sd">                         used to created its ONNX name (i.e., the</span>
<span class="sd">                         field *onnx_name* below).</span>
<span class="sd">        :param onnx_name: A string indicating the variable&#39;s name in</span>
<span class="sd">                          the converted model</span>
<span class="sd">        :param scope: A string. It&#39;s the name of the scope where this</span>
<span class="sd">                      variable is declared</span>
<span class="sd">        :param type: A type object defined in .common.data_types.py;</span>
<span class="sd">                     e.g., FloatTensorType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span> <span class="o">=</span> <span class="n">raw_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>  <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="c1"># The following fields are bool variables used in parsing and</span>
        <span class="c1"># compiling stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">DataType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be a DataType not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be a tuple or a list not &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_fct</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must contains integers not &quot;</span>
                                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique variable ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Variable(raw_name=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, type=</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_pb</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a data type from a protobuf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dim_value</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">))]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Variable</span><span class="o">.</span><span class="n">from_pb</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">elem_type</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">BooleanTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">DoubleTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">StringTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int64TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int32TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; (elem_type=</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">),</span> <span class="n">elem</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; as &quot;</span>
                                      <span class="s2">&quot;a string (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ty</span><span class="p">)</span></div>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="n">OperatorBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an operator available in *ONNX*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param onnx_name: A unique ID, which is a string</span>
<span class="sd">        :param scope: The name of the scope where this operator is</span>
<span class="sd">                      declared. It&#39;s a string.</span>
<span class="sd">        :param type: A object which uniquely characterizes the type of</span>
<span class="sd">                     this operator. For example, it can be a string,</span>
<span class="sd">                     pooling, if this operator is associated with a</span>
<span class="sd">                     CoreML pooling layer.</span>
<span class="sd">        :param raw_operator: The original operator which defines this operator;</span>
<span class="sd">                             for example, a scikit-learn Imputer and</span>
<span class="sd">                             a CoreML Normalizer.</span>
<span class="sd">        :param dtype: preferred output type</span>
<span class="sd">        :param target_opset: The target opset number for the converted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Parameter raw_operator must be an object not &quot;</span>
                               <span class="s2">&quot;a string &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">))</span>
        <span class="c1"># operator name in the converted model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">raw_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique operator ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all input variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all output variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original operator/layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span>

    <span class="k">def</span> <span class="nf">infer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke a core inference function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="n">shape_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tensor_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FloatTensorType</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FloatTensorType</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to guess the tensor type from </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proto_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dtype should be either np.float32 or &quot;</span>
                             <span class="s2">&quot;np.float64.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Scope"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope">[docs]</a><span class="k">class</span> <span class="nc">Scope</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Every node of an *ONNX* graph must be unique. This class holds the list</span>
<span class="sd">    of existing name for every node already defined in graph. It also</span>
<span class="sd">    provides functions to create a unique unused name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">variable_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">operator_name_set</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: A string, the unique ID of this scope in a</span>
<span class="sd">                     Topology object</span>
<span class="sd">        :param parent_scopes: A list of Scope objects. The last element</span>
<span class="sd">                              should be the direct parent scope (i.e.,</span>
<span class="sd">                              where this scope is declared).</span>
<span class="sd">        :param variable_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of variables</span>
<span class="sd">        :param operator_name_set: A set of strings serving as the name</span>
<span class="sd">                                  pool of operators</span>
<span class="sd">        :param target_opset: The target opset number for the converted</span>
<span class="sd">                             model.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying</span>
<span class="sd">                                the user customized shape calculator</span>
<span class="sd">        :param dtype: select the computation for real type,</span>
<span class="sd">            by default it is float but double is sometime needed</span>
<span class="sd">        :param options: see :ref:`l-conv-options`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_scopes</span> <span class="o">=</span> <span class="n">parent_scopes</span> <span class="k">if</span> <span class="n">parent_scopes</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">variable_name_set</span> <span class="k">if</span> <span class="n">variable_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">operator_name_set</span> <span class="k">if</span> <span class="n">operator_name_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="n">custom_shape_calculators</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor_type</span> <span class="o">=</span> <span class="n">FloatTensorType</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor_type</span> <span class="o">=</span> <span class="n">DoubleTensorType</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor_type</span> <span class="o">=</span> <span class="n">Int64TensorType</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;dtype must be either np.float32, np.float64, &quot;</span>
                <span class="s2">&quot;np.int64.&quot;</span><span class="p">)</span>

        <span class="c1"># An one-to-many map from raw variable name to ONNX variable</span>
        <span class="c1"># names. It looks like</span>
        <span class="c1"># (key, value) = (raw_name, [onnx_name, onnx_name1, onnx_name2, ..., onnx_nameN]) # noqa</span>
        <span class="c1"># The last name may hide all other names in this scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local variables defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, variable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local operators defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, operator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Additional options given to converters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

    <span class="k">def</span> <span class="nf">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape calculator for the given model type.</span>

<span class="sd">        :param model_type: model type such as *LogisticRegression*</span>
<span class="sd">        :return: alias or None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Scope.get_unique_variable_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_variable_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique variable ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter seed must be a string not </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Scope.get_unique_operator_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_operator_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_operator_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique operator ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">declare_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function may create a new variable in this scope. If</span>
<span class="sd">        *raw_name* has been used to create other variables, the new</span>
<span class="sd">        variable will hide all other variables created using *raw_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get unique ID for the new variable</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">)</span>

        <span class="c1"># Create the variable</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

        <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="c1"># Hide existing variables with the same raw_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">declare_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to declare new local operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_operator_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="k">return</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">delete_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the operator whose onnx_name is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The operator to remove was not found.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">delete_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the variable whose *onnx_name* is the input *onnx_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="ow">or</span>
                <span class="n">onnx_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The variable to remove was not found.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="n">raw_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span><span class="o">.</span><span class="n">raw_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns additional options for a model.</span>
<span class="sd">        It first looks by class then by id (``id(model)``).</span>
<span class="sd">        :param model: model being converted</span>
<span class="sd">        :param default_values: default options (it is modified by</span>
<span class="sd">                               the function)</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_build_options</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">default_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds instances on :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;` and</span>
<span class="sd">    :class:`SklearnModelContainer &lt;skl2onnx.common._container.SklearnModelContainer&gt;`.</span>
<span class="sd">    These are filled by the converters while a pipeline is being converted.</span>
<span class="sd">    When all converters were called, method</span>
<span class="sd">    :meth:`Topology.compile &lt;skl2onnx.common._topology.Topology.compile&gt;`</span>
<span class="sd">    must be called to convert the topological graph into *ONNX* graph.</span>
<span class="sd">    &quot;&quot;&quot;</span> <span class="c1"># noqa</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reserved_variable_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reserved_operator_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_conversion_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_props</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a *Topology* object, which is an intermediate</span>
<span class="sd">        representation of a computational graph.</span>

<span class="sd">        :param model: RawModelContainer object or one of its derived</span>
<span class="sd">                      classes. It contains the original model.</span>
<span class="sd">        :param default_batch_size: batch_size prepend to scalar and</span>
<span class="sd">                                   array types from CoreML. It&#39;s usually</span>
<span class="sd">                                   1 or None.</span>
<span class="sd">        :param initial_types: A list providing some types for some</span>
<span class="sd">                              root variables.</span>
<span class="sd">        Each element is a tuple of a variable name and a type defined</span>
<span class="sd">        in *data_types.py*.</span>
<span class="sd">        :param reserved_variable_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a variable</span>
<span class="sd">                                        name</span>
<span class="sd">        :param reserved_operator_names: A set of strings which are not</span>
<span class="sd">                                        allowed to be used as a operator</span>
<span class="sd">                                        name</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying the</span>
<span class="sd">                                        user customized shape calculator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reserved_variable_names</span>
                    <span class="k">if</span> <span class="n">reserved_variable_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">reserved_operator_names</span>
                    <span class="k">if</span> <span class="n">reserved_operator_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span> <span class="o">=</span> <span class="n">initial_types</span> <span class="k">if</span> <span class="n">initial_types</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_props</span> <span class="o">=</span> <span class="n">metadata_props</span> <span class="k">if</span> <span class="n">metadata_props</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_batch_size</span> <span class="o">=</span> <span class="n">default_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_conversion_functions</span> <span class="k">if</span> <span class="n">custom_conversion_functions</span> <span class="k">else</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_shape_calculators</span> <span class="k">if</span> <span class="n">custom_shape_calculators</span> <span class="k">else</span> <span class="p">{})</span>

        <span class="c1"># This attribute is used in optimizing the graph structure. If</span>
        <span class="c1"># root_names is not empty, only the variables specified will be</span>
        <span class="c1"># treated as the roots (i.e., set is_fed to True in the</span>
        <span class="c1"># beginning of a graph evaluation) of the graph. Specifying all</span>
        <span class="c1"># root variables in this list and leaving it empty are</span>
        <span class="c1"># equivalent. This attribute directly affects</span>
        <span class="c1"># _initialize_graph_status_for_traversing function and</span>
        <span class="c1"># indirectly affects _infer_all_shapes and _prune functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_conversion_functions must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_shape_calculators must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>

        <span class="c1"># A map of local overwritten model aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_model_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">)</span>
                           <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">all_model_types</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mtype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">existing_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce an unique string based on the seed</span>
<span class="sd">        :param seed: a string</span>
<span class="sd">        :param existing_names: a set containing strings which cannot be</span>
<span class="sd">                               produced</span>
<span class="sd">        :return: a string similar to the seed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Name seed must be a non-empty string.&#39;</span><span class="p">)</span>

        <span class="c1"># Make the seed meet C-style naming convention</span>
        <span class="c1"># Only alphabets and numbers are allowed</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^0-9a-zA-Z]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="c1"># The first symbol cannot be a number</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[0-9]&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">seed</span>

        <span class="c1"># If seed has never been seen, we return it as it is. Otherwise,</span>
        <span class="c1"># we will append an number to make it unique.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">get_unique_scope_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;`</span>
<span class="sd">        and appends it to the list of existing scopes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_scope_name</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="n">parent_scopes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator_name_set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">unordered_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">unordered_variable_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">topological_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an iterator of all operators in Topology object.</span>
<span class="sd">        Operators may be produced in a topological order. If you want to</span>
<span class="sd">        simply go though all operators without considering their</span>
<span class="sd">        topological structure, please use another function,</span>
<span class="sd">        unordered_operator_iterator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;tensorToProbabilityMap&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;tensorToLabel&#39;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span>
                      <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">(),</span>
                                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="n">priorities</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
                                   <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">priorities</span> <span class="k">else</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">):</span>
                    <span class="c1"># Check if over-writing problem occurs (i.e., multiple</span>
                    <span class="c1"># operators produce results on one variable).</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="c1"># Throw an error if this variable has been treated as</span>
                        <span class="c1"># an output somewhere</span>
                        <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                <span class="s1">&#39;One variable can only be &#39;</span>
                                <span class="s1">&#39;assigned once: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>
                        <span class="c1"># Mark this variable as filled</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Make this operator as handled</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">is_evaluation_happened</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Send out an operator</span>
                    <span class="k">yield</span> <span class="n">operator</span>
            <span class="c1"># After scanning through the whole computational graph, at</span>
            <span class="c1"># least one operator should be evaluated. If not, we need</span>
            <span class="c1"># to terminate this procedure to avoid dead lock.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_evaluation_happened</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_check_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to check if the parsed model is</span>
<span class="sd">        proper. Currently, it only checks if isolated variable and</span>
<span class="sd">        isolated operator exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect all variable names and operator names</span>
        <span class="n">unused_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">unused_operators</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="n">unused_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="n">unused_operators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an input, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># A variable is used by an operator, so we remove the</span>
                <span class="c1"># variable from the unused-variable list.</span>
                <span class="n">unused_variables</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="c1"># A operator has an output, so we remove the operator</span>
                <span class="c1"># from the unused-operator list.</span>
                <span class="n">unused_operators</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated variables exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_variables</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused_operators</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Isolated operators exist: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="n">unused_operators</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_graph_status_for_traversing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the status of all variables and operators for</span>
<span class="sd">        traversing the underline graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In the beginning, we set is_root and is_leaf true. For is_fed,</span>
        <span class="c1"># we have two different behaviors depending on whether</span>
        <span class="c1"># root_names is empty.</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="c1"># If root_names is set, we only set those variable to be</span>
            <span class="c1"># fed. Otherwise, all roots would be fed.</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="ow">and</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span>
                               <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_names</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Then, we flip some flags by applying some simple rules so</span>
        <span class="c1"># that only</span>
        <span class="c1">#   1. all roots get is_root=True and is_fed=True</span>
        <span class="c1">#   2. all leaves get is_leaf=True</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># All operators are not processed in the beginning</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># Output cannot be fed before graph traversing</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># If the variable is an output of one operator,</span>
                <span class="c1"># it must not be a root</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                <span class="c1"># If the variable is an input of one operator,</span>
                <span class="c1"># it must not be a leaf</span>
                <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_infer_all_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infer all variables&#39; shapes in the computational graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Deliver user-specified types to root variables</span>
        <span class="k">for</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">initial_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span><span class="p">:</span>
            <span class="c1"># Check all variables declared using raw_name in</span>
            <span class="c1"># the whole graph</span>
            <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="c1"># Skip scopes without having the considered variable</span>
                <span class="c1"># name</span>
                <span class="k">if</span> <span class="n">raw_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># Assign initial_type to all variables declared using</span>
                <span class="c1"># raw_name</span>
                <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">raw_name</span><span class="p">]:</span>
                    <span class="n">variable</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Assign type to the root; existing type</span>
                        <span class="c1"># produced by parser may be overwritten</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">initial_type</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="c1"># overwritten operator.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">mtype</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">](</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_shape_calculator&quot;</span><span class="p">):</span>
                <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_shape_calculator</span><span class="p">()</span>
                <span class="n">shape_calc</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">infer_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_resolve_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge variables connected by identity operator to reduce the</span>
<span class="sd">        number of redundant variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Traverse the graph from roots to leaves</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;identity&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_root</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">)):</span>
                <span class="k">continue</span>

            <span class="c1"># Replace the output variable with the input variable everywhere</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">duplicate</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">another_scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">another_operator</span> <span class="ow">in</span> <span class="n">another_scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">onnx_name</span>
                                <span class="o">!=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">another_operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">original</span>

            <span class="c1"># When original variable&#39;s documentation string or</span>
            <span class="c1"># denotation is empty but duplicate&#39;s is not, we copy that</span>
            <span class="c1"># field to the original variable to avoid information loss.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span><span class="p">:</span>
                <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">doc_string</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="ow">and</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">denotation</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">:</span>
                    <span class="c1"># Merge the channel denotations if available in both</span>
                    <span class="c1"># the original and the duplicate</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">channel_denotations</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Sometime, shapes of duplicates are different. We try</span>
                <span class="c1"># to replace the original variable&#39;s unknown dimensions</span>
                <span class="c1"># as many as possible because we will get rid of the</span>
                <span class="c1"># duplicate.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">original</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Because we&#39;re iterating through the topology, we cannot</span>
            <span class="c1"># delete any operator or variable. Otherwise, the traversing</span>
            <span class="c1"># function may be broken. We will delete those abandoned</span>
            <span class="c1"># ones later.</span>
            <span class="n">duplicate</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Find out who is going to be abandoned</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">onnx_name</span> <span class="k">for</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_abandoned</span><span class="p">)</span>

            <span class="c1"># Remove abandoned operators</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># Remove abandoned variables</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fix_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function applies some rules to adjust graph inputs</span>
<span class="sd">        (i.e., roots) before doing shape inference</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Identify roots of a graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

        <span class="c1"># Scan through all operators and adjust their variables&#39; shapes</span>
        <span class="c1"># if needed</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="c1"># Rule 1 (CoreML):</span>
            <span class="c1"># Some operator in CoreML only accepts 4-D tensors but</span>
            <span class="c1"># their protobuf models might specify a 2-D one.</span>
            <span class="c1"># We fix this problem here.</span>
            <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;concat&#39;</span><span class="p">,</span> <span class="s1">&#39;convolution&#39;</span><span class="p">,</span> <span class="s1">&#39;crop&#39;</span><span class="p">,</span> <span class="s1">&#39;flatten&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;scalerPreprocessor&#39;</span><span class="p">,</span> <span class="s1">&#39;lrn&#39;</span><span class="p">,</span> <span class="s1">&#39;meanImagePreprocessor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;padding&#39;</span><span class="p">,</span> <span class="s1">&#39;permute&#39;</span><span class="p">,</span> <span class="s1">&#39;pooling&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;reorganizeData&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="s1">&#39;upsample&#39;</span><span class="p">]:</span>
                <span class="c1"># We only adjust inputs because outputs will be</span>
                <span class="c1"># automatically fixed at our shape inference stage</span>
                <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                        <span class="c1"># Convert [N, C] to [N, C, 1, 1] while</span>
                        <span class="c1"># [N, C, H, W] is unchanged</span>
                        <span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                            <span class="mi">4</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Conduct a dummy evaluation of this topology. It may set all</span>
        <span class="c1"># reachable operators evaluated and all reachable variables fed.</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
            <span class="k">pass</span>

        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="c1"># Remove unused operators</span>
            <span class="n">abandoned_operator_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
                    <span class="n">abandoned_operator_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_operator_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

            <span class="c1"># Remove unused variables</span>
            <span class="n">abandoned_variable_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                    <span class="n">abandoned_variable_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">abandoned_variable_names</span><span class="p">:</span>
                <span class="n">scope</span><span class="o">.</span><span class="n">delete_local_variable</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">)</span>

<div class="viewcode-block" id="Topology.compile"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function aims at giving every operator enough information</span>
<span class="sd">        so that all operator conversions can happen independently. We</span>
<span class="sd">        also want to check, fix, and simplify the network structure</span>
<span class="sd">        here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fix_shapes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infer_all_types</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_structure</span><span class="p">()</span></div></div>


<span class="k">def</span> <span class="nf">convert_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">doc_string</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">,</span>
                     <span class="n">channel_first_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to convert our Topology object defined in</span>
<span class="sd">    _parser.py into a ONNX model (type: ModelProto).</span>
<span class="sd">    :param topology: The Topology object we are going to convert</span>
<span class="sd">    :param model_name: GraphProto&#39;s name. Let &quot;model&quot; denote the</span>
<span class="sd">                       returned model. The string &quot;model_name&quot; would be</span>
<span class="sd">                       assigned to &quot;model.graph.name.&quot;</span>
<span class="sd">    :param doc_string: A string attached to the produced model</span>
<span class="sd">    :param target_opset: number, for example, 7 for ONNX 1.2, and 8 for</span>
<span class="sd">                         ONNX 1.3.</span>
<span class="sd">    :param dtype: float type to use everywhere in the graph,</span>
<span class="sd">        `np.float32` or `np.float64`</span>
<span class="sd">    :param options: see :ref:`l-conv-options`</span>
<span class="sd">    include &#39;1.1.2&#39;, &#39;1.2&#39;, and so on.</span>
<span class="sd">    :return: a ONNX ModelProto</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dtype must be specified.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">target_opset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_opset</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">target_opset</span> <span class="o">&gt;</span> <span class="n">get_opset_number_from_onnx</span><span class="p">():</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;number of the installed onnx package. See &quot;</span>
            <span class="s2">&quot;https://github.com/onnx/onnx/blob/master/docs/Versioning.md#released-versions&quot;</span> <span class="c1"># noqa</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>

    <span class="n">topology</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">ModelComponentContainer</span><span class="p">(</span>
        <span class="n">target_opset</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Put roots and leaves as ONNX&#39;s model into buffers. They will be</span>
    <span class="c1"># added into ModelComponentContainer later.</span>
    <span class="n">tensor_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_inputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tensor_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">other_outputs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_inputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span>
                                              <span class="n">FloatType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">)):</span>
                    <span class="n">tensor_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_outputs</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>

    <span class="c1"># Add roots the graph according to their order in the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nhwc_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">channel_first_inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">channel_first_inputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="c1"># Check input naming convention</span>
        <span class="n">input_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">input_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                           <span class="p">(</span><span class="ow">not</span> <span class="n">input_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_inputs</span><span class="p">:</span>
            <span class="c1"># type: Variable</span>
            <span class="n">onnx_input</span> <span class="o">=</span> <span class="n">tensor_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:0&#39;</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">channel_first_inputs</span><span class="p">)):</span>
                <span class="n">nhwc_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onnx_input</span><span class="o">.</span><span class="n">full_name</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">onnx_input</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">onnx_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some input names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">input_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_inputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">other_inputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Add leaves the graph according to their order in</span>
    <span class="c1"># the original model</span>
    <span class="n">invalid_name</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="c1"># Check output naming convention</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">output_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="ow">not</span> <span class="n">output_name</span><span class="o">.</span><span class="n">isalnum</span><span class="p">())):</span>
            <span class="n">invalid_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tensor_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">tensor_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">invalid_name</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some output names are not compliant with ONNX naming &#39;</span>
                      <span class="s1">&#39;convention: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">invalid_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">output_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">other_outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">other_outputs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="c1"># Traverse the graph from roots to leaves</span>
    <span class="c1"># This loop could eventually be parallelized.</span>
    <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">topological_operator_iterator</span><span class="p">():</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">scope</span> <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">scopes</span>
                     <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">operator</span><span class="o">.</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_converter&quot;</span><span class="p">):</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_converter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the selected operator into some ONNX objects and</span>
            <span class="c1"># save them into the container</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingConverter</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to find converter for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; type &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;. You may raise an issue at &quot;</span>
                    <span class="s2">&quot;https://github.com/onnx/sklearn-onnx/issues.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                              <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;raw_model&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))))</span>
        <span class="n">conv</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="c1"># Create a graph from its main components</span>
    <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1"># When calling ModelComponentContainer&#39;s add_initializer(...),</span>
        <span class="c1"># nothing is added into the input list. However, for ONNX target</span>
        <span class="c1"># opset &lt; 9, initializers should also be a part of model&#39;s</span>
        <span class="c1"># (GraphProto) inputs. Thus, we create ValueInfoProto objects</span>
        <span class="c1"># from initializers (type: TensorProto) directly and then add</span>
        <span class="c1"># them into model&#39;s input list.</span>
        <span class="n">extra_inputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ValueInfoProto list of the initializers</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">:</span>
            <span class="c1"># Sometimes (especially when creating optional input values</span>
            <span class="c1"># such as RNN&#39;s initial hidden state), an initializer is also</span>
            <span class="c1"># one of the original model&#39;s input, so it has been added into</span>
            <span class="c1"># the container&#39;s input list. If this is the case, we need to</span>
            <span class="c1"># skip one iteration to avoid duplicated inputs.</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">value_info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">value_info</span> <span class="ow">in</span>
                               <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Initializers are always tensors so we can just call</span>
            <span class="c1"># make_tensor_value_info(...).</span>
            <span class="n">value_info</span> <span class="o">=</span> <span class="n">make_tensor_value_info</span><span class="p">(</span>
                <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">extra_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_info</span><span class="p">)</span>

        <span class="c1"># Before ONNX opset 9, initializers were needed to be passed in</span>
        <span class="c1"># with inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">extra_inputs</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># In ONNX opset 9 and above, initializers are included as</span>
        <span class="c1"># operator inputs and therefore do not need to be passed as</span>
        <span class="c1"># extra_inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span>
            <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>

    <span class="c1"># Add extra information related to the graph</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create model</span>
    <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">make_model</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Merge operator sets for the same domain, the largest version</span>
    <span class="c1"># number would be kept</span>
    <span class="n">purified_operator_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">node_domain_version_pair_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">],</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Fill operator sets</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Overwrite the default operator set created by</span>
            <span class="c1"># make_model(...)</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Just create one ONNX element in opset_import</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">op_domain</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">((</span><span class="s1">&#39;The specified opset </span><span class="si">%d</span><span class="s1"> is too low to convert &#39;</span>
                                <span class="s1">&#39;this model, which requires at least opset &#39;</span>
                                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">op_version</span><span class="p">))</span>

    <span class="c1"># Add extra information</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">IR_VERSION</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_name</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">model_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_model_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

    <span class="k">return</span> <span class="n">onnx_model</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo_main.png" alt="Logo"/>
            </a></p><h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation index</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../skl2onnx.html">skl2onnx</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2018-2019, Microsoft.
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
  </div>
  
  </body>
</html>