<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>skl2onnx.common._topology - sklearn-onnx 1.14.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">sklearn-onnx 1.14.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/logo_main.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">sklearn-onnx 1.14.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../index_tutorial.html">Tutorial</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_1_simple.html">The easy case</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_abegin_convert_pipeline.html">Train and deploy a scikit-learn pipeline</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_bbegin_measure_time.html">Benchmark ONNX conversion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_cbegin_opset.html">What is the opset number?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_dbegin_options.html">One model, many possible conversions with options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_dbegin_options_zipmap.html">Choose appropriate output of a classifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_dbegin_options_list.html">Black list operators when converting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_ebegin_float_double.html">Issues when switching to float</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_fbegin_investigate.html">Intermediate results and investigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gbegin_cst.html">Store arrays in one onnx graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gbegin_dataframe.html">Dataframe as an input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gconverting.html">Modify the ONNX graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gbegin_transfer_learning.html">Transfer Learning with ONNX</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_1-5_external.html">Using converters from other libraries</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gexternal_lightgbm.html">Convert a pipeline with a LightGBM classifier</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gexternal_lightgbm_reg.html">Convert a pipeline with a LightGBM regressor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gexternal_xgboost.html">Convert a pipeline with a XGBoost model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_gexternal_catboost.html">Convert a pipeline with a CatBoost classifier</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_2_new_converter.html">A custom converter for a custom model</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_icustom_converter.html">Implement a new converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_jcustom_syntax.html">Two ways to implement a converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_kcustom_converter_wrapper.html">Implement a new converter using other converters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_lcustom_options.html">A new converter with options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_mcustom_parser.html">Change the number of outputs by adding a parser</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_3_new_operator.html">Extend ONNX, extend runtime</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_pextend_python_runtime.html">Fast design with a python runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_qextend_onnxruntime.html">Fast runtime with onnxruntime</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_4_advanced.html">Advanced scenarios</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_ngrams.html">Tricky issue when converting CountVectorizer or TfidfVectorizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_usparse_xgboost.html">TfIdf and sparse matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_woe_transformer.html">Converter for WOE</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../tutorial_2-5_extlib.html">Write converters for other libraries</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../auto_tutorial/plot_wext_pyod_forest.html">Converter for pyod.models.iforest.IForest</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_summary.html">API Summary</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../auto_examples/index.html">Gallery of examples</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_metadata.html">Metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_pipeline.html">Draw a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_backend.html">ONNX Runtime Backend for ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_logging.html">Logging, verbose</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_convert_decision_function.html">Probabilities or raw scores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_convert_model.html">Train, convert and predict a model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_investigate_pipeline.html">Investigate a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_benchmark_cdist.html">Compare CDist with scipy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_pipeline_lightgbm.html">Convert a pipeline with a LightGbm model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_convert_zipmap.html">Probabilities as a vector or as a ZipMap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_black_op.html">Convert a model with a reduced list of operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_benchmark_pipeline.html">Benchmark a pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_pipeline_xgboost.html">Convert a pipeline with a XGBoost model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_nmf.html">Custom Operator for NMF Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_cast_transformer.html">Discrepencies with StandardScaler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_gpr.html">Discrepencies with GaussianProcessorRegressor: use of double</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_errors_onnxruntime.html">Errors with onnxruntime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_onnx_operators.html">Play with ONNX operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_convert_syntax.html">Different ways to convert a model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_tfidfvectorizer.html">TfIdfVectorizer with ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_complex_pipeline.html">Convert a pipeline with ColumnTransformer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_intermediate_outputs.html">Walk through intermediate outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_custom_parser_alternative.html">When a custom model is neither a classifier nor a regressor (alternative)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_custom_parser.html">When a custom model is neither a classifier nor a regressor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../auto_examples/plot_custom_model.html">Write your own converter for your own model</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline.html">Convert a pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../parameterized.html">Converters with options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../supported.html">Supported scikit-learn Models</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for skl2onnx.common._topology</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-License-Identifier: Apache-2.0</span>


<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">onnx</span> <span class="kn">import</span> <span class="n">onnx_pb</span> <span class="k">as</span> <span class="n">onnx_proto</span>
<span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa</span>
    <span class="n">DataType</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>
    <span class="n">FloatType</span><span class="p">,</span> <span class="n">Int64Type</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span>
    <span class="n">DictionaryType</span><span class="p">,</span> <span class="n">FloatTensorType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">Int64TensorType</span><span class="p">,</span> <span class="n">SequenceType</span><span class="p">,</span>  <span class="c1"># noqa</span>
    <span class="n">StringTensorType</span><span class="p">,</span> <span class="n">DoubleTensorType</span><span class="p">,</span>
    <span class="n">Int32TensorType</span><span class="p">,</span> <span class="n">BooleanTensorType</span><span class="p">,</span>
    <span class="n">DoubleTensorType</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.data_types</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">Int8TensorType</span><span class="p">,</span> <span class="n">UInt8TensorType</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Int8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">UInt8TensorType</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">from</span> <span class="nn">..proto</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_opset_number_from_onnx</span><span class="p">,</span>
    <span class="n">get_latest_tested_opset_version</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..proto.onnx_helper_modified</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">make_graph</span><span class="p">,</span> <span class="n">make_model</span><span class="p">,</span> <span class="n">make_tensor_value_info</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_registration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">MissingShapeCalculator</span><span class="p">,</span> <span class="n">MissingConverter</span>
<span class="kn">from</span> <span class="nn">._container</span> <span class="kn">import</span> <span class="n">ModelComponentContainer</span><span class="p">,</span> <span class="n">_build_options</span>
<span class="kn">from</span> <span class="nn">.onnx_optimisation_identity</span> <span class="kn">import</span> <span class="n">onnx_remove_node_identity</span>

<span class="n">type_fct</span> <span class="o">=</span> <span class="nb">type</span>


<span class="k">def</span> <span class="nf">_default_OPSET_TO_IR_VERSION</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="mi">7</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="mi">13</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">17</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">:</span> <span class="mi">8</span>
    <span class="p">}</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">onnxconverter_common.topology</span> <span class="kn">import</span> <span class="n">OPSET_TO_IR_VERSION</span>
    <span class="k">assert</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
    <span class="n">OPSET_TO_IR_VERSION</span> <span class="o">=</span> <span class="n">_default_OPSET_TO_IR_VERSION</span><span class="p">()</span>

<span class="n">OPSET_ML_TO_OPSET</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">18</span><span class="p">}</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;skl2onnx&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_default_opset_for_domain</span><span class="p">(</span><span class="n">domain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the associated for a domain given the main opset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">__max_supported_opset__</span> <span class="k">as</span> <span class="n">main_opset</span>
    <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">main_opset</span>
    <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;ai.onnx.ml&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">main_opset</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">main_opset</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;ai.onnx.training&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="Variable"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Variable">[docs]</a><span class="k">class</span> <span class="nc">Variable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable which holds any data defined</span>
<span class="sd">    from *ONNX* types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_UNIQUE_NUMBER_</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param raw_name: A string indicating the variable&#39;s name in the</span>
<span class="sd">                         original model. Usually, it&#39;s the seed string</span>
<span class="sd">                         used to created its ONNX name (i.e., the</span>
<span class="sd">                         field *onnx_name* below).</span>
<span class="sd">        :param onnx_name: A string indicating the variable&#39;s name in</span>
<span class="sd">                          the converted model</span>
<span class="sd">        :param scope: A string. It&#39;s the name of the scope where this</span>
<span class="sd">                      variable is declared</span>
<span class="sd">        :param type: A type object defined in .common.data_types.py;</span>
<span class="sd">                     e.g., FloatTensorType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;raw_name must be a string not &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="n">raw_name</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected type for variable raw_name=</span><span class="si">%r</span><span class="s2">, type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;(&#39;</span> <span class="ow">in</span> <span class="n">onnx_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">onnx_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;u(&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">onnx_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="n">onnx_name0</span> <span class="o">=</span> <span class="n">onnx_name</span>
                <span class="k">if</span> <span class="n">scope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">onnx_name</span> <span class="o">=</span> <span class="s2">&quot;UU</span><span class="si">%03d</span><span class="s2">UU&quot;</span> <span class="o">%</span> <span class="n">Variable</span><span class="o">.</span><span class="n">_UNIQUE_NUMBER_</span>
                    <span class="n">Variable</span><span class="o">.</span><span class="n">_UNIQUE_NUMBER_</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">onnx_name</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="s2">&quot;U&quot;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;[Var] rename raw_name=</span><span class="si">%r</span><span class="s1">, onnx_name=</span><span class="si">%r</span><span class="s1"> into </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name0</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;onnx_name must be a string not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">onnx_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">not_none</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">shape</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">not_none</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;A variable cannot be empty, raw_name=</span><span class="si">%r</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;onnx_name=</span><span class="si">%r</span><span class="s2">, shape=</span><span class="si">%r</span><span class="s2">, type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span> <span class="o">=</span> <span class="n">raw_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The following fields are bool variables used in parsing and</span>
        <span class="c1"># compiling stages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">DataType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;shape must be a DataType not </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shape must be a tuple or a list not &quot;</span>
                                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_fct</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;shape must contains integers not </span><span class="si">%r</span><span class="s2"> (type=</span><span class="si">%r</span><span class="s2">).&quot;</span>
                        <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] +</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># links to operators using those variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators_outputs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators_inputs_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Unexpected type </span><span class="si">%r</span><span class="s2"> for shape </span><span class="si">%r</span><span class="s2">.&quot;</span>
                        <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scope</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_fed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span>

    <span class="k">def</span> <span class="nf">init_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_fed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_fed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_fed</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;[Var] update is_fed=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">, parent=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="n">is_fed</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_fed</span> <span class="o">=</span> <span class="n">is_fed</span>
        <span class="k">if</span> <span class="n">is_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_root</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update is_root=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">is_root</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_root</span> <span class="o">=</span> <span class="n">is_root</span>
        <span class="k">if</span> <span class="n">is_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_leaf</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update is_leaf=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">is_leaf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_leaf</span> <span class="o">=</span> <span class="n">is_leaf</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;onnx_name&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You must use method set_onnx_name.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;is_fed&quot;</span><span class="p">,</span> <span class="s2">&quot;is_root&quot;</span><span class="p">,</span> <span class="s2">&quot;is_leaf&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You must use method init_status.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;scope&#39;</span><span class="p">,</span> <span class="s1">&#39;raw_name&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;scope or raw_name cannot be changed.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Variable</span><span class="p">))</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected new type for variable </span><span class="si">%r</span><span class="s2">, new_type=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Var] update type for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">new_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">onnx_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;[Var] update onnx_name, from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1"> in </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">rename_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>

    <span class="k">def</span> <span class="nf">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;This variable is already the output of operator </span><span class="si">%r</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;It cannot be the output of </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">operator</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;[Var] set parent for </span><span class="si">%r</span><span class="s1">, parent=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">get_first_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first dimension (batch dimension) or</span>
<span class="sd">        None if not specified (shape is empty).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_second_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique variable ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Variable(&#39;</span><span class="si">{0}</span><span class="s2">&#39;, &#39;</span><span class="si">{1}</span><span class="s2">&#39;, type=</span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_pb</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a data type from a protobuf object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_dim</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dim_value</span>
            <span class="k">if</span> <span class="s2">&quot;dim_param&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># dim_value is 0 when it is 0 or undefined</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="s2">&quot;0&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">get_dim</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">dim</span><span class="p">))]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;extend&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Variable</span><span class="o">.</span><span class="n">from_pb</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">:</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">elem_type</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">BOOL</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">BooleanTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">DoubleTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">StringTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int64TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int32TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">UInt8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">UINT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">UInt8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">Int8TensorType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">elem</span> <span class="o">==</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">TensorProto</span><span class="o">.</span><span class="n">INT8</span><span class="p">):</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">Int8TensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ty</span> <span class="o">=</span> <span class="n">FloatTensorType</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; (elem_type=</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">tensor_type</span><span class="p">),</span> <span class="n">elem</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unsupported type &#39;</span><span class="si">{}</span><span class="s2">&#39; as &quot;</span>
                                      <span class="s2">&quot;a string (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                          <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">obj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ty</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Enables expression such as `a,b = self`.&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Unreachable element at index </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_or_out</span><span class="p">):</span>
        <span class="s2">&quot;Add a link to an operator, True for output, False for input.&quot;</span>
        <span class="k">if</span> <span class="n">in_or_out</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_compatible_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">empty_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">elif</span> <span class="n">other_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_type</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other_type</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">empty_shape</span><span class="p">(</span><span class="n">other_type</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Incompatible type for variable </span><span class="si">%r</span><span class="s2"> and type </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other_type</span><span class="p">))</span></div>


<span class="k">class</span> <span class="nc">VariableStr</span><span class="p">(</span><span class="n">Variable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a variable a string. This should be avoided.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Variable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;u(&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Variable should be renamed as onnx_name=</span><span class="si">%r</span><span class="s2">.&quot;</span>
                <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onnx_name</span>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an operator available in *ONNX*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">class</span> <span class="nc">OperatorList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Operator equal not implemented and not needed.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Input and output must be of type Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;Out&#39;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Op] add </span><span class="si">%s</span><span class="s2"> </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;In&#39;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;Out&quot;</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Unexpected value for kind=</span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Element </span><span class="si">%d</span><span class="s2"> must be a Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span>
                <span class="s2">&quot;Setter should not be used to modify an element.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="s2">&quot;Updates element i.&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Value v must be a Variable not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;[Op] </span><span class="si">%s</span><span class="s2">-change element </span><span class="si">%d</span><span class="s2"> from </span><span class="si">%r</span><span class="s2"> to </span><span class="si">%r</span><span class="s2"> in </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;onnx_name&#39;</span><span class="p">):</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param onnx_name: A unique ID, which is a string</span>
<span class="sd">        :param scope: The name of the scope where this operator is</span>
<span class="sd">                      declared. It&#39;s a string.</span>
<span class="sd">        :param type: A object which uniquely characterizes the type of</span>
<span class="sd">                     this operator. For example, it can be a string,</span>
<span class="sd">                     pooling, if this operator is associated with a</span>
<span class="sd">                     CoreML pooling layer.</span>
<span class="sd">        :param raw_operator: The original operator which defines this operator;</span>
<span class="sd">                             for example, a scikit-learn Imputer and</span>
<span class="sd">                             a CoreML Normalizer.</span>
<span class="sd">        :param target_opset: The target opset number for the converted model.</span>
<span class="sd">        :param scope_inst: :class:`Scope` instance the operator belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Parameter raw_operator must be an object not &quot;</span>
                               <span class="s2">&quot;a string &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raw_operator</span><span class="p">))</span>
        <span class="c1"># operator name in the converted model, if raw_operator</span>
        <span class="c1"># is not None, output_shapes can be guessed</span>
        <span class="c1"># from the raw model. Otherwise, it can be guessed</span>
        <span class="c1"># from the input shapes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">=</span> <span class="n">onnx_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">raw_operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;In&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Out&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_inst</span> <span class="o">=</span> <span class="n">scope_inst</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Op] +</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">new_raw_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a shallow copy of this operator,</span>
<span class="sd">        changes the raw_operator but keeps the same inputs</span>
<span class="sd">        and outputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">raw_operator</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_inst</span><span class="p">)</span>
        <span class="n">op</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">op</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>
        <span class="k">return</span> <span class="n">op</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="s2">&quot;MISSING OP&quot;</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># The line above fails for python 3.7</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">textop</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">textop</span><span class="p">:</span>
            <span class="n">textop</span> <span class="o">=</span> <span class="n">textop</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;Operator(type=&#39;</span><span class="si">{0}</span><span class="s2">&#39;, onnx_name=&#39;</span><span class="si">{1}</span><span class="s2">&#39;, inputs=&#39;</span><span class="si">{2}</span><span class="s2">&#39;, &quot;</span>
                <span class="s2">&quot;outputs=&#39;</span><span class="si">{3}</span><span class="s2">&#39;, raw_operator=</span><span class="si">{4}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                    <span class="n">textop</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;outputs&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;inputs&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;In&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;outputs&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Out&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;inputs or outputs must be of type Operator.OperatorList.&quot;</span><span class="p">)</span>
            <span class="n">ioo</span> <span class="o">=</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;outputs&#39;</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="n">v</span><span class="o">.</span><span class="n">add_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ioo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_evaluated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span>

    <span class="k">def</span> <span class="nf">init_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_evaluated</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_evaluated</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_evaluated</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;[Op] update is_evaluated=</span><span class="si">%r</span><span class="s1"> for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="n">is_evaluated</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_evaluated</span> <span class="o">=</span> <span class="n">is_evaluated</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a globally unique operator ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all input variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_full_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all output variables&#39; names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">full_name</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">original_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the original operator/layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span>

    <span class="k">def</span> <span class="nf">infer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Invoke a core inference function</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find a shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">shape_calc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingShapeCalculator</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected shape calculator for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;and type &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Shape-a] </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
        <span class="n">shape_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Shape-b] </span><span class="si">%r</span><span class="s2"> inputs=</span><span class="si">%r</span><span class="s2"> - outputs=</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Scope"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope">[docs]</a><span class="k">class</span> <span class="nc">Scope</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Every node of an *ONNX* graph must be unique. This class holds the list</span>
<span class="sd">    of existing name for every node already defined in graph. It also</span>
<span class="sd">    provides functions to create a unique unused name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">naming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: A string, the unique ID of this scope in a</span>
<span class="sd">                     Topology object</span>
<span class="sd">        :param target_opset: The target opset number for the converted</span>
<span class="sd">                             model.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying</span>
<span class="sd">                                the user customized shape calculator</span>
<span class="sd">        :param options: see :ref:`l-conv-options`</span>
<span class="sd">        :param naming: the user may want to change the way intermediate</span>
<span class="sd">            are named, this parameter can be a string (a prefix) or a</span>
<span class="sd">            function, which signature is the following:</span>
<span class="sd">            `get_name(name, existing_names)`, the library will then</span>
<span class="sd">            check this name is unique and modify it if not</span>
<span class="sd">        :param registered_models: registered models</span>

<span class="sd">        .. versionchanged:: 1.10.0</span>
<span class="sd">            Parameter *naming* was added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="n">custom_shape_calculators</span>

        <span class="c1"># An one-to-many map from raw variable name to ONNX variable</span>
        <span class="c1"># names. It looks like</span>
        <span class="c1"># (key, value) = (raw_name, [onnx_name, onnx_name1, onnx_name2, ..., onnx_nameN]) # noqa</span>
        <span class="c1"># The last name may hide all other names in this scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A map of local variables defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, variable)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_variables</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A map of local operators defined in this scope.</span>
        <span class="c1"># (key, value) = (onnx_name, operator)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Additional options given to converters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="c1"># Registered models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">naming</span> <span class="o">=</span> <span class="n">naming</span>

        <span class="k">if</span> <span class="n">naming</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">naming</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">naming</span> <span class="o">+</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">naming</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">names</span><span class="p">),</span> <span class="n">names</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Unexpected type for parameter naming: </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">naming</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">):</span>
        <span class="s2">&quot;Returns variable with &#39;name&#39; or default value is not found.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">has_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tells if a variable is already registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span>

    <span class="k">def</span> <span class="nf">get_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shape calculator for the given model type.</span>

<span class="sd">        :param model_type: model type such as *LogisticRegression*</span>
<span class="sd">        :return: alias or None if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Scope.get_unique_variable_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_variable_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique variable ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter seed must be a string not </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span>
                <span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Scope.get_unique_operator_name"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Scope.get_unique_operator_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_operator_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a unique operator ID based on the given seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_naming</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">declare_local_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">missing_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function may create a new variable in this scope. If</span>
<span class="sd">        *raw_name* has been used to create other variables, the new</span>
<span class="sd">        variable will hide all other variables created using *raw_name*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">missing_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown type for </span><span class="si">%r</span><span class="s2"> (type=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span>
        <span class="c1"># Get unique ID for the new variable</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_variable_name</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>

        <span class="c1"># Create the variable</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">register_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="s2">&quot;Adds a variable to the scope.&quot;</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Variable </span><span class="si">%r</span><span class="s2"> already registered (other=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">var</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">:</span>
            <span class="c1"># Hide existing variables with the same raw_name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">declare_existing_subgraph_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_proto</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Declare all name from a subgraph in order to avoid being picked twice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">graph_proto</span><span class="o">.</span><span class="n">output</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph_proto</span><span class="o">.</span><span class="n">node</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">output_name</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_variable_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                        <span class="s2">&quot;Result name </span><span class="si">%r</span><span class="s2"> is already taken (outputs=</span><span class="si">%r</span><span class="s2">) &quot;</span>
                        <span class="s2">&quot;(node=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="n">name</span><span class="p">,</span> <span class="n">output_name</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">onnx_variable_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s2">&quot;Operator name </span><span class="si">%r</span><span class="s2"> is already taken &quot;</span>
                    <span class="s2">&quot;(node=</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onnx_operator_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename_onnx_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Name </span><span class="si">%r</span><span class="s2"> already in variables (</span><span class="si">%r</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">new_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">old_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Unable to find name </span><span class="si">%r</span><span class="s2"> in variables.&quot;</span> <span class="o">%</span> <span class="n">old_name</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;[Scope] update onnx_name, from </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">declare_local_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `declare_local_variable`. Registers this variable</span>
<span class="sd">        as an input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_local_variable</span><span class="p">(</span>
            <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">declare_local_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">missing_type</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `declare_local_variable`. Registers this variable</span>
<span class="sd">        as an output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_local_variable</span><span class="p">(</span>
            <span class="n">raw_name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span>
            <span class="n">missing_type</span><span class="o">=</span><span class="n">missing_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">declare_local_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is used to declare new local operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">onnx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_operator_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">))</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">onnx_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">raw_model</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span> <span class="n">scope_inst</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="k">return</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">_get_allowed_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
                        <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">return</span> <span class="p">{}</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;aliases&#39;</span><span class="p">][</span><span class="nb">type</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">[</span><span class="s1">&#39;conv&#39;</span><span class="p">][</span><span class="n">alias</span><span class="p">]</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">get_allowed_options</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">allowed</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;No registered models, no known allowed options &quot;</span>
            <span class="s2">&quot;for model &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">add_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an option, for example,</span>
<span class="sd">        ``add_options(id(clr), {&#39;raw_scores&#39;: True})``</span>
<span class="sd">        tells the converter associated to ``clr`` to</span>
<span class="sd">        use raw score instead of probabilities.</span>

<span class="sd">        :param model_id: class or ``id(instance)``</span>
<span class="sd">        :param options: dictionary with the new values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">model_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">model_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns additional options for a model.</span>
<span class="sd">        It first looks by class then by id (``id(model)``).</span>
<span class="sd">        :param model: model being converted</span>
<span class="sd">        :param default_values: default options (it is modified by</span>
<span class="sd">                               the function)</span>
<span class="sd">        :param fail: fails if option it not found</span>
<span class="sd">        :return: dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_build_options</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">default_values</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_allowed_options</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">),</span>
            <span class="n">fail</span><span class="o">=</span><span class="n">fail</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_raw_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces every raw operator op1 by op2.</span>
<span class="sd">        The function uses `id()` to detect op1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">op1</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;[Scope] replace </span><span class="si">%d</span><span class="s1"> by </span><span class="si">%d</span><span class="s1"> in </span><span class="si">%r</span><span class="s1">.&#39;</span><span class="p">,</span>
                    <span class="nb">id</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">v</span><span class="o">.</span><span class="n">raw_operator</span> <span class="o">=</span> <span class="n">op2</span>
                <span class="n">v</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">alias</span></div>


<div class="viewcode-block" id="Topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.Topology">[docs]</a><span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds instances on :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;` and</span>
<span class="sd">    :class:`SklearnModelContainer</span>
<span class="sd">    &lt;skl2onnx.common._container.SklearnModelContainer&gt;`.</span>
<span class="sd">    These are filled by the converters while a pipeline is being converted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">default_batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">target_opset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">custom_conversion_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a *Topology* object, which is an intermediate</span>
<span class="sd">        representation of a computational graph.</span>

<span class="sd">        :param model: RawModelContainer object or one of its derived</span>
<span class="sd">                      classes. It contains the original model.</span>
<span class="sd">        :param default_batch_size: batch_size prepend to scalar and</span>
<span class="sd">                                   array types from CoreML. It&#39;s usually</span>
<span class="sd">                                   1 or None.</span>
<span class="sd">        :param initial_types: A list providing some types for some</span>
<span class="sd">                              root variables.</span>
<span class="sd">        Each element is a tuple of a variable name and a type defined</span>
<span class="sd">        in *data_types.py*.</span>
<span class="sd">        :param custom_conversion_functions: a dictionary for specifying</span>
<span class="sd">                                the user customized conversion function</span>
<span class="sd">        :param custom_shape_calculators: a dictionary for specifying the</span>
<span class="sd">                                        user customized shape calculator</span>
<span class="sd">        :param registered_models: registered models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span> <span class="o">=</span> <span class="n">initial_types</span> <span class="k">if</span> <span class="n">initial_types</span> <span class="k">else</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_batch_size</span> <span class="o">=</span> <span class="n">default_batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_conversion_functions</span> <span class="k">if</span> <span class="n">custom_conversion_functions</span> <span class="k">else</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">custom_shape_calculators</span> <span class="k">if</span> <span class="n">custom_shape_calculators</span> <span class="k">else</span> <span class="p">{})</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_conversion_functions must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Keys in custom_shape_calculators must be &quot;</span>
                                <span class="s2">&quot;types not strings.&quot;</span><span class="p">)</span>

        <span class="c1"># A map of local overwritten model aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_model_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">)</span>
                           <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="n">all_model_types</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mtype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_aliases</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias</span>

        <span class="c1"># Registered models</span>
        <span class="k">if</span> <span class="n">registered_models</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span> <span class="o">=</span> <span class="n">registered_models</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope is allowed not </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">existing_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce an unique string based on the seed</span>
<span class="sd">        :param seed: a string</span>
<span class="sd">        :param existing_names: a set containing strings which cannot be</span>
<span class="sd">                               produced</span>
<span class="sd">        :return: a string similar to the seed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Name seed must be a non-empty string.&#39;</span><span class="p">)</span>

        <span class="c1"># Make the seed meet C-style naming convention</span>
        <span class="c1"># Only alphabets and numbers are allowed</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[^</span><span class="se">\\</span><span class="s1">w+]&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="c1"># The first symbol cannot be a number</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[0-9]&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">seed</span>

        <span class="c1"># If seed has never been seen, we return it as it is. Otherwise,</span>
        <span class="c1"># we will append an number to make it unique.</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">seed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">existing_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span>

    <span class="k">def</span> <span class="nf">get_unique_scope_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Topology</span><span class="o">.</span><span class="n">_generate_unique_name</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scope_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">parent_scopes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">naming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`Scope &lt;skl2onnx.common._topology.Scope&gt;`</span>
<span class="sd">        and appends it to the list of existing scopes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope can be created.&quot;</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_scope_name</span><span class="p">(</span><span class="n">seed</span><span class="p">),</span> <span class="n">target_opset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_opset</span><span class="p">,</span>
            <span class="n">custom_shape_calculators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">registered_models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">registered_models</span><span class="p">,</span>
            <span class="n">naming</span><span class="o">=</span><span class="n">naming</span><span class="p">)</span>

        <span class="c1"># Declare input variables.</span>
        <span class="c1"># They should be the inputs of the scikit-learn</span>
        <span class="c1"># model you want to convert into ONNX.</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">initial_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_types</span><span class="p">:</span>
            <span class="n">scope</span><span class="o">.</span><span class="n">declare_local_input</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">initial_type</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">unordered_operator_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">operator</span>

    <span class="k">def</span> <span class="nf">unordered_variable_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">variable</span>

    <span class="k">def</span> <span class="nf">call_converter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s2">&quot;Calls converter for operator *operator*.&quot;</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">:</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_conversion_functions</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_converter&quot;</span><span class="p">):</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_converter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert the selected operator into some ONNX objects and</span>
            <span class="c1"># save them into the container</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">_registration</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingConverter</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to find converter for alias &#39;</span><span class="si">{}</span><span class="s2">&#39; type &quot;</span>
                    <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;. You may raise an issue at &quot;</span>
                    <span class="s2">&quot;https://github.com/onnx/sklearn-onnx/issues.&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                              <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;raw_model&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))))</span>

        <span class="n">container</span><span class="o">.</span><span class="n">validate_options</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[call_converter] call converter for </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[Conv] call </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
        <span class="n">conv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Conv] end - </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call_shape_calculator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="s2">&quot;Calls shape_calculator for operator *operator*.&quot;</span>
        <span class="n">mtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="c1"># overwritten operator.</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">mtype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_shape_calculators</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">,</span> <span class="s2">&quot;onnx_shape_calculator&quot;</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;onnx_shape_calculator&#39;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="o">.</span><span class="n">onnx_shape_calculator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">shape_calc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">shape_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;[Shape1] </span><span class="si">%r</span><span class="s2"> fed </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2"> (source=</span><span class="si">%r</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">),</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">is_fed</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
                <span class="n">source</span><span class="p">)</span>
            <span class="n">shape_calc</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;[Shape2] call infer_types for </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">infer_types</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize_graph_status_for_traversing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the status of all variables and operators before</span>
<span class="sd">        traversing the graph. Only used by convert_operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Only one scope is allowed not </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">))</span>
        <span class="n">input_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected inputs.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
            <span class="n">is_input</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span> <span class="ow">in</span> <span class="n">input_names</span>
            <span class="n">variable</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="n">is_input</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_evaluated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_propagate_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">fed_variables</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Propagates status *is_fed* based on output variable</span>
<span class="sd">        and node added in the container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[_propagate_status] after op=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">operator</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="nb">vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[_propagate_status] newly fed=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_fed</span><span class="p">))</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fed_variables</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                    <span class="n">nodes</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">fed_variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[_propagate_status] add=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span>
                            <span class="n">fed_variables</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                                <span class="n">var</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[_propagate_status] fed=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls all converters and shape_calculator for existing</span>
<span class="sd">        operators. It also processes new operators created by</span>
<span class="sd">        converters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_check_operator_</span><span class="p">(</span><span class="n">operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;operator.inputs must be a Operator.OperatorList &quot;</span>
                    <span class="s2">&quot;not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">Operator</span><span class="o">.</span><span class="n">OperatorList</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;operator.outputs must be a Operator.OperatorList &quot;</span>
                    <span class="s2">&quot;not </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;One input is not a Variable for operator </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="n">operator</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;One output is not a Variable for operator </span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">.&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span><span class="p">),</span> <span class="n">operator</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_check_variable_in_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
            <span class="n">idop</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Operator </span><span class="si">%r</span><span class="s2"> not registered in the list of operators &quot;</span>
                    <span class="s2">&quot;of </span><span class="si">%r</span><span class="s2"> taking it as an input [</span><span class="se">\n</span><span class="si">%s</span><span class="s2">].&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">operator</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">))))</span>

        <span class="k">def</span> <span class="nf">_check_variable_out_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                <span class="n">add</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;--DEBUG-INFO--&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span>
                        <span class="n">scope</span><span class="o">.</span><span class="n">variable_name_mapping</span><span class="p">))</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_fed=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> - n_in=</span><span class="si">%d</span><span class="s2"> n_out=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;is_fed&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">var</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">),</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">)))</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">operators</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;   is_evaluated=</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;is_evaluated&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">),</span> <span class="n">op</span><span class="p">))</span>
                <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;---&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; inputs=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; outputs=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;--- operator producing this variable--&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">:</span>
                    <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;A variable is already assigned (</span><span class="si">{}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;for operator &#39;</span><span class="si">{}</span><span class="s2">&#39; (name=&#39;</span><span class="si">{}</span><span class="s2">&#39;). &quot;</span>
                    <span class="s2">&quot;operator.is_evaluated=</span><span class="si">{}</span><span class="s2">, inputs.is_fed=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;outputs.is_fed=</span><span class="si">{}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;This may still happen if a converter is a &quot;</span>
                    <span class="s2">&quot;combination of sub-estimators and one &quot;</span>
                    <span class="s2">&quot;of them is producing this output. &quot;</span>
                    <span class="s2">&quot;In that case, an identity node must be &quot;</span>
                    <span class="s2">&quot;added.</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                        <span class="n">operator</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">,</span>
                        <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">],</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">add</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] begin&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_graph_status_for_traversing</span><span class="p">()</span>
        <span class="n">fed_variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">}</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">changes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] iteration </span><span class="si">%d</span><span class="s2"> - n_vars=</span><span class="si">%d</span><span class="s2"> &quot;</span>
                      <span class="s2">&quot;n_ops=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                          <span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fed_variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
                <span class="n">_check_operator_</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">is_fed</span><span class="p">:</span>
                        <span class="n">fed_variables</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">is_fed</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">):</span>

                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
                        <span class="n">_check_variable_in_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="n">_check_variable_out_</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">operator</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">call_shape_calculator</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">call_converter</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

                    <span class="c1"># If an operator contains a sequence of operators,</span>
                    <span class="c1"># output variables are not necessarily known at this stage.</span>
                    <span class="n">operator</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_evaluated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span>
                               <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">variable</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">):</span>
                            <span class="n">variable</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">fed_variables</span><span class="p">[</span><span class="n">variable</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable</span>
                    <span class="n">fed_variables</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span>
                         <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_status</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">fed_variables</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

                    <span class="c1"># unfed some variables (it happens when a node</span>
                    <span class="c1"># shares an output with another node)</span>
                    <span class="n">rem</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fed_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;operators_outputs_&#39;</span><span class="p">):</span>
                            <span class="c1"># initializer</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">is_evaluated</span>
                               <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">):</span>
                            <span class="n">rem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rem</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">fed_variables</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">init_status</span><span class="p">(</span><span class="n">is_fed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">fed_variables</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">]</span>
                    <span class="n">changes</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] end iter: </span><span class="si">%d</span><span class="s2"> - n_vars=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fed_variables</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] end.&quot;</span><span class="p">)</span>

        <span class="c1"># Last verification.</span>
        <span class="n">not_evaluated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">:</span>
                <span class="n">not_evaluated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_evaluated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;---VARS---&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;is_fed=</span><span class="si">%r</span><span class="s2"> is_leaf=</span><span class="si">%r</span><span class="s2"> is_root=</span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2"> - n_in=</span><span class="si">%d</span><span class="s2"> n_out=</span><span class="si">%d</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">is_fed</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">is_root</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_inputs_</span><span class="p">),</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">operators_outputs_</span><span class="p">)))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;---OPERATORS---&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_operator_iterator</span><span class="p">():</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;is_eval=</span><span class="si">%r</span><span class="s2"> - </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_evaluated</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;---NODES---&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Not all operators have been evaluated. A variable name &quot;</span>
                <span class="s2">&quot;is probably misspelled.</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="s2">&quot;&quot;</span> <span class="o">%</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>

        <span class="c1"># Input and output</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_variables</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">()</span>
                      <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_root</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">()</span>
                   <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">]</span>

        <span class="c1"># The function checks that for output variable,</span>
        <span class="c1"># raw_name equal onnx_name. It swaps names if it is not the case.</span>
        <span class="n">to_swap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">raw_name</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">:</span>
                <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_swap</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">swaped</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">to_swap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span> <span class="ow">in</span> <span class="n">swaped</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">swaped</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[convert_operators] </span><span class="si">%r</span><span class="s2"> &lt;-&gt; </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span><span class="p">))</span>
                <span class="n">old_name</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">onnx_name</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">raw_name</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">container</span><span class="o">.</span><span class="n">swap_names</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s1">&#39;[Topo] unable to swap </span><span class="si">%r</span><span class="s1"> and </span><span class="si">%r</span><span class="s1"> (</span><span class="si">%r</span><span class="s1">).&#39;</span><span class="p">,</span>
                        <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_variable_iterator</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">set_onnx_name</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">onnx_name</span> <span class="o">==</span> <span class="n">new_name</span><span class="p">:</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">set_onnx_name</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">container</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_topology"><a class="viewcode-back" href="../../../api_summary.html#skl2onnx.common._topology.convert_topology">[docs]</a><span class="k">def</span> <span class="nf">convert_topology</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">doc_string</span><span class="p">,</span> <span class="n">target_opset</span><span class="p">,</span>
                     <span class="n">channel_first_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_identity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to convert our Topology object defined in</span>
<span class="sd">    _parser.py into a ONNX model (type: ModelProto).</span>

<span class="sd">    :param topology: The Topology object we are going to convert</span>
<span class="sd">    :param model_name: GraphProto&#39;s name. Let &quot;model&quot; denote the</span>
<span class="sd">        returned model. The string &quot;model_name&quot; would be</span>
<span class="sd">        assigned to &quot;model.graph.name.&quot;</span>
<span class="sd">    :param doc_string: A string attached to the produced model</span>
<span class="sd">    :param target_opset: number or dictionary,</span>
<span class="sd">        for example, 7 for ONNX 1.2, and 8 for ONNX 1.3,</span>
<span class="sd">        a dictionary is used to indicate different opset for</span>
<span class="sd">        different domains</span>
<span class="sd">    :param options: see :ref:`l-conv-options`</span>
<span class="sd">    :param remove_identity: removes identity nodes</span>
<span class="sd">        include &#39;1.1.2&#39;, &#39;1.2&#39;, and so on.</span>
<span class="sd">    :param verbose: displays information while converting</span>
<span class="sd">    :return: a ONNX ModelProto</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_opset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_opset</span> <span class="o">=</span> <span class="n">get_latest_tested_opset_version</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_opset</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">get_latest_tested_opset_version</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">onnx_target_opset</span> <span class="o">=</span> <span class="n">target_opset</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_opset_number_from_onnx</span><span class="p">():</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">get_opset_number_from_onnx</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;version of the installed onnx package. See &quot;</span>
            <span class="s2">&quot;https://github.com/onnx/onnx/blob/master/docs/&quot;</span>
            <span class="s2">&quot;Versioning.md#released-versions&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span> <span class="n">found</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">onnx_target_opset</span> <span class="o">&gt;</span> <span class="n">get_latest_tested_opset_version</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Parameter target_opset </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2"> is higher than the &quot;</span>
            <span class="s2">&quot;the latest tested version&quot;</span>
            <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">onnx_target_opset</span><span class="p">,</span>
                <span class="n">get_latest_tested_opset_version</span><span class="p">()))</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">ModelComponentContainer</span><span class="p">(</span>
        <span class="n">target_opset</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
        <span class="n">registered_models</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">registered_models</span><span class="p">,</span>
        <span class="n">white_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_white_op</span><span class="p">,</span>
        <span class="n">black_op</span><span class="o">=</span><span class="n">topology</span><span class="o">.</span><span class="n">raw_model</span><span class="o">.</span><span class="n">_black_op</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># Traverse the graph from roots to leaves</span>
    <span class="c1"># This loop could eventually be parallelized.</span>
    <span class="n">topology</span><span class="o">.</span><span class="n">convert_operators</span><span class="p">(</span><span class="n">container</span><span class="o">=</span><span class="n">container</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">container</span><span class="o">.</span><span class="n">ensure_topological_order</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected inputs after conversion.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No detected outputs after conversion.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---NODES---&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">: </span><span class="si">%r</span><span class="s2"> -&gt; </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">op_type</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="p">))</span>

    <span class="c1"># Create a graph from its main components</span>
    <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_onnx</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1"># When calling ModelComponentContainer&#39;s add_initializer(...),</span>
        <span class="c1"># nothing is added into the input list. However, for ONNX target</span>
        <span class="c1"># opset &lt; 9, initializers should also be a part of model&#39;s</span>
        <span class="c1"># (GraphProto) inputs. Thus, we create ValueInfoProto objects</span>
        <span class="c1"># from initializers (type: TensorProto) directly and then add</span>
        <span class="c1"># them into model&#39;s input list.</span>
        <span class="n">extra_inputs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># ValueInfoProto list of the initializers</span>
        <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">:</span>
            <span class="c1"># Sometimes (especially when creating optional input values</span>
            <span class="c1"># such as RNN&#39;s initial hidden state), an initializer is also</span>
            <span class="c1"># one of the original model&#39;s input, so it has been added into</span>
            <span class="c1"># the container&#39;s input list. If this is the case, we need to</span>
            <span class="c1"># skip one iteration to avoid duplicated inputs.</span>
            <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">value_info</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">value_info</span> <span class="ow">in</span>
                               <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Initializers are always tensors so we can just call</span>
            <span class="c1"># make_tensor_value_info(...).</span>
            <span class="n">value_info</span> <span class="o">=</span> <span class="n">make_tensor_value_info</span><span class="p">(</span>
                <span class="n">tensor</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">extra_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_info</span><span class="p">)</span>

        <span class="c1"># Before ONNX opset 9, initializers were needed to be passed in</span>
        <span class="c1"># with inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">inputs</span> <span class="o">+</span> <span class="n">extra_inputs</span><span class="p">,</span>
                           <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># In ONNX opset 9 and above, initializers are included as</span>
        <span class="c1"># operator inputs and therefore do not need to be passed as</span>
        <span class="c1"># extra_inputs.</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">make_graph</span><span class="p">(</span>
            <span class="n">container</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">container</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">initializers</span><span class="p">)</span>

    <span class="c1"># Add extra information related to the graph</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">value_info</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">value_info</span><span class="p">)</span>

    <span class="c1"># Create model</span>
    <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">make_model</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="c1"># Update domain version</span>
    <span class="n">opv</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">onnx_target_opset</span><span class="p">,</span>
              <span class="n">_get_main_opset_version</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span> <span class="ow">or</span> <span class="n">onnx_target_opset</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
        <span class="c1"># Main opset was not added. Doing it here.</span>
        <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">opv</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[convert_topology] +opset: name=</span><span class="si">%r</span><span class="s1">, version=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">opv</span><span class="p">))</span>

    <span class="c1"># Add extra information</span>
    <span class="n">irv</span> <span class="o">=</span> <span class="n">OPSET_TO_IR_VERSION</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">opv</span><span class="p">,</span> <span class="n">onnx_proto</span><span class="o">.</span><span class="n">IR_VERSION</span><span class="p">)</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">ir_version</span> <span class="o">=</span> <span class="n">irv</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_name</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">producer_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_producer_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_domain</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">model_version</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">get_model_version</span><span class="p">()</span>
    <span class="n">onnx_model</span><span class="o">.</span><span class="n">doc_string</span> <span class="o">=</span> <span class="n">doc_string</span>

    <span class="c1"># Removes many identity nodes,</span>
    <span class="c1"># the converter may introduct identity nodes</span>
    <span class="c1"># after a zipmap operator and onnx &lt;= 1.7 does not</span>
    <span class="c1"># support that. It does not use onnxconverter-common</span>
    <span class="c1"># as the optimizer only support opset &gt;= 9.</span>
    <span class="k">if</span> <span class="n">remove_identity</span><span class="p">:</span>
        <span class="n">onnx_model</span> <span class="o">=</span> <span class="n">onnx_remove_node_identity</span><span class="p">(</span><span class="n">onnx_model</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">onnx_model</span></div>


<span class="k">def</span> <span class="nf">_update_domain_version</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">onnx_model</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># Merge operator sets for the same domain, the largest version</span>
    <span class="c1"># number would be kept</span>
    <span class="n">purified_operator_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">container</span><span class="o">.</span><span class="n">node_domain_version_pair_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op_domain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">op_version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">purified_operator_set</span><span class="p">[</span><span class="n">op_domain</span><span class="p">],</span> <span class="n">op_version</span><span class="p">)</span>

    <span class="c1"># Fill operator sets</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span> <span class="ow">in</span> <span class="n">purified_operator_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">op_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Overwrite the default operator set created by</span>
            <span class="c1"># make_model(...)</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Just create one ONNX element in opset_import</span>
            <span class="n">op_set</span> <span class="o">=</span> <span class="n">onnx_model</span><span class="o">.</span><span class="n">opset_import</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[_update_domain_version] +opset </span><span class="si">%d</span><span class="s1">: name=</span><span class="si">%r</span><span class="s1">, version=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_version</span><span class="p">))</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">op_domain</span>
        <span class="k">if</span> <span class="n">op_set</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">max_supported</span> <span class="o">=</span> <span class="n">get_default_opset_for_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_supported</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_supported</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;The model is using version </span><span class="si">%d</span><span class="s2"> of domain </span><span class="si">%r</span><span class="s2"> not supported &quot;</span>
                    <span class="s2">&quot;yet by this library. You need to specify &quot;</span>
                    <span class="s2">&quot;target_opset={</span><span class="si">%r</span><span class="s2">: </span><span class="si">%r</span><span class="s2">}.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">op_version</span><span class="p">,</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">op_domain</span><span class="p">,</span> <span class="n">max_supported</span><span class="p">))</span>
        <span class="n">op_set</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">op_version</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">op_version</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;The specified opset </span><span class="si">%d</span><span class="s1"> is too low to convert &#39;</span>
                <span class="s1">&#39;this model, which requires at least opset &#39;</span>
                <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">container</span><span class="o">.</span><span class="n">target_opset_any_domain</span><span class="p">(</span><span class="n">op_domain</span><span class="p">),</span>
                    <span class="n">op_version</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">purified_operator_set</span>


<span class="k">def</span> <span class="nf">_get_main_opset_version</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the main opset version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mld</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">opset_import</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="s2">&quot;ai.onnx.ml&quot;</span><span class="p">:</span>
            <span class="n">mld</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">version</span>
    <span class="k">if</span> <span class="n">mld</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">OPSET_ML_TO_OPSET</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mld</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2018-2022, Microsoft
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>