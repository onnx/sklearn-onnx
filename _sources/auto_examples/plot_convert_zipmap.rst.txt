
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_convert_zipmap.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_convert_zipmap.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_convert_zipmap.py:


.. _l-rf-example-zipmap:

Probabilities as a vector or as a ZipMap
========================================

A classifier usually returns a matrix of probabilities.
By default, *sklearn-onnx* converts that matrix
into a list of dictionaries where each probabily is mapped
to its class id or name. That mechanism retains the class names.
This conversion increases the prediction time and is not
always needed. Let's see how to deactivate this behaviour
on the Iris example.

Train a model and convert it
++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 22-45

.. code-block:: Python


    from timeit import repeat
    import numpy
    import sklearn
    from sklearn.datasets import load_iris
    from sklearn.model_selection import train_test_split
    import onnxruntime as rt
    import onnx
    import skl2onnx
    from skl2onnx.common.data_types import FloatTensorType
    from skl2onnx import convert_sklearn
    from sklearn.linear_model import LogisticRegression

    iris = load_iris()
    X, y = iris.data, iris.target
    X_train, X_test, y_train, y_test = train_test_split(X, y)
    clr = LogisticRegression(max_iter=500)
    clr.fit(X_train, y_train)
    print(clr)

    initial_type = [("float_input", FloatTensorType([None, 4]))]
    onx = convert_sklearn(clr, initial_types=initial_type, target_opset=12)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    LogisticRegression(max_iter=500)




.. GENERATED FROM PYTHON SOURCE LINES 46-51

Output type
+++++++++++

Let's confirm the output type of the probabilities
is a list of dictionaries with onnxruntime.

.. GENERATED FROM PYTHON SOURCE LINES 51-58

.. code-block:: Python


    sess = rt.InferenceSession(onx.SerializeToString(), providers=["CPUExecutionProvider"])
    res = sess.run(None, {"float_input": X_test.astype(numpy.float32)})
    print(res[1][:2])
    print("probabilities type:", type(res[1]))
    print("type for the first observations:", type(res[1][0]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [{0: 0.9855462312698364, 1: 0.014453794807195663, 2: 2.6966477051360016e-08}, {0: 0.9758896231651306, 1: 0.02411031350493431, 2: 6.119217488276263e-08}]
    probabilities type: <class 'list'>
    type for the first observations: <class 'dict'>




.. GENERATED FROM PYTHON SOURCE LINES 59-63

Without ZipMap
++++++++++++++

Let's remove the ZipMap operator.

.. GENERATED FROM PYTHON SOURCE LINES 63-78

.. code-block:: Python


    initial_type = [("float_input", FloatTensorType([None, 4]))]
    options = {id(clr): {"zipmap": False}}
    onx2 = convert_sklearn(
        clr, initial_types=initial_type, options=options, target_opset=12
    )

    sess2 = rt.InferenceSession(
        onx2.SerializeToString(), providers=["CPUExecutionProvider"]
    )
    res2 = sess2.run(None, {"float_input": X_test.astype(numpy.float32)})
    print(res2[1][:2])
    print("probabilities type:", type(res2[1]))
    print("type for the first observations:", type(res2[1][0]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[9.8554623e-01 1.4453795e-02 2.6966477e-08]
     [9.7588962e-01 2.4110314e-02 6.1192175e-08]]
    probabilities type: <class 'numpy.ndarray'>
    type for the first observations: <class 'numpy.ndarray'>




.. GENERATED FROM PYTHON SOURCE LINES 79-85

One output per class
++++++++++++++++++++

This options removes the final operator ZipMap and splits
the probabilities into columns. The final model produces
one output for the label, and one output per class.

.. GENERATED FROM PYTHON SOURCE LINES 85-103

.. code-block:: Python


    options = {id(clr): {"zipmap": "columns"}}
    onx3 = convert_sklearn(
        clr, initial_types=initial_type, options=options, target_opset=12
    )

    sess3 = rt.InferenceSession(
        onx3.SerializeToString(), providers=["CPUExecutionProvider"]
    )
    res3 = sess3.run(None, {"float_input": X_test.astype(numpy.float32)})
    for i, out in enumerate(sess3.get_outputs()):
        print(
            "output: '{}' shape={} values={}...".format(
                out.name, res3[i].shape, res3[i][:2]
            )
        )






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    output: 'output_label' shape=(38,) values=[0 0]...
    output: 'i0' shape=(38,) values=[0.98554623 0.9758896 ]...
    output: 'i1' shape=(38,) values=[0.01445379 0.02411031]...
    output: 'i2' shape=(38,) values=[2.6966477e-08 6.1192175e-08]...




.. GENERATED FROM PYTHON SOURCE LINES 104-106

Let's compare prediction time
+++++++++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 106-125

.. code-block:: Python


    X32 = X_test.astype(numpy.float32)

    print("Time with ZipMap:")
    print(repeat(lambda: sess.run(None, {"float_input": X32}), number=100, repeat=10))

    print("Time without ZipMap:")
    print(repeat(lambda: sess2.run(None, {"float_input": X32}), number=100, repeat=10))

    print("Time without ZipMap but with columns:")
    print(repeat(lambda: sess3.run(None, {"float_input": X32}), number=100, repeat=10))

    # The prediction is much faster without ZipMap
    # on this example.
    # The optimisation is even faster when the classes
    # are described with strings and not integers
    # as the final result (list of dictionaries) may copy
    # many times the same information with onnxruntime.





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Time with ZipMap:
    [0.007650300998648163, 0.008157159994880203, 0.007525455999711994, 0.007710575999226421, 0.0032167190001928248, 0.003425537004659418, 0.0047001670027384534, 0.003106750998995267, 0.0029996040029800497, 0.0041698999993968755]
    Time without ZipMap:
    [0.007040286000119522, 0.0014692410040879622, 0.0016817340001580305, 0.0014042769980733283, 0.0013281419960549101, 0.0012773979979101568, 0.0014685019996250048, 0.0014107499955571257, 0.0019871380063705146, 0.0027347759969416074]
    Time without ZipMap but with columns:
    [0.002820116002112627, 0.00241675599681912, 0.0067874320011469536, 0.0069814079979551025, 0.00912039299873868, 0.007295570998394396, 0.007226800997159444, 0.002324020999367349, 0.006959972997719888, 0.011624457998550497]




.. GENERATED FROM PYTHON SOURCE LINES 126-127

**Versions used for this example**

.. GENERATED FROM PYTHON SOURCE LINES 127-133

.. code-block:: Python


    print("numpy:", numpy.__version__)
    print("scikit-learn:", sklearn.__version__)
    print("onnx: ", onnx.__version__)
    print("onnxruntime: ", rt.__version__)
    print("skl2onnx: ", skl2onnx.__version__)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    numpy: 2.4.1
    scikit-learn: 1.8.0
    onnx:  1.21.0
    onnxruntime:  1.24.0
    skl2onnx:  1.20.0





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.229 seconds)


.. _sphx_glr_download_auto_examples_plot_convert_zipmap.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_convert_zipmap.ipynb <plot_convert_zipmap.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_convert_zipmap.py <plot_convert_zipmap.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_convert_zipmap.zip <plot_convert_zipmap.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
