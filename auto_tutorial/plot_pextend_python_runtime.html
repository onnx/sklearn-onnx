
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Fast design with a python runtime &#8212; sklearn-onnx 1.9.1.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/readable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Fast runtime with onnxruntime" href="plot_qextend_onnxruntime.html" />
    <link rel="prev" title="Extend ONNX, extend runtime" href="../tutorial_3_new_operator.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="plot_qextend_onnxruntime.html" title="Fast runtime with onnxruntime"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../tutorial_3_new_operator.html" title="Extend ONNX, extend runtime"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">sklearn-onnx 1.9.1.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index_tutorial.html" >Tutorial</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../tutorial_3_new_operator.html" accesskey="U">Extend ONNX, extend runtime</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Fast design with a python runtime</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-auto-tutorial-plot-pextend-python-runtime-py"><span class="std std-ref">here</span></a>
to download the full example code or to run this example in your browser via Binder</p>
</div>
<section class="sphx-glr-example-title" id="fast-design-with-a-python-runtime">
<span id="l-extend-python-runtime"></span><span id="sphx-glr-auto-tutorial-plot-pextend-python-runtime-py"></span><h1>Fast design with a python runtime<a class="headerlink" href="#fast-design-with-a-python-runtime" title="Permalink to this headline">¶</a></h1>
<p id="index-0"><a class="reference external" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md">ONNX operators</a> do not contain all operators
from <a class="reference external" href="https://numpy.org/">numpy</a>. There is no operator for
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html">solve</a> but this one
is needed to implement the prediction function
of model <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.NMF.html">NMF</a>. The converter can be written
including a new ONNX operator but then it requires a
runtime for it to be tested. This example shows how
to do that with the python runtime implemented in
<a class="reference external" href="http://www.xavierdupre.fr/app/mlprodict/helpsphinx/index.html">mlprodict</a>. It may not be <a class="reference external" href="https://microsoft.github.io/onnxruntime/">onnxruntime</a>
but that speeds up the implementation of the converter.</p>
<p>The example changes the transformer from
<a class="reference internal" href="plot_icustom_converter.html#l-plot-custom-converter"><span class="std std-ref">Implement a new converter</span></a>, the method <em>predict</em>
decorrelates the variables by computing the eigen
values. Method <em>fit</em> does not do anything anymore.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#a-transformer-which-decorrelates-variables" id="id1">A transformer which decorrelates variables</a></p></li>
<li><p><a class="reference internal" href="#extend-onnx" id="id2">Extend ONNX</a></p>
<ul>
<li><p><a class="reference internal" href="#new-onnx-operator" id="id3">New ONNX operator</a></p></li>
<li><p><a class="reference internal" href="#shape-calculator" id="id4">shape calculator</a></p></li>
<li><p><a class="reference internal" href="#converter" id="id5">converter</a></p></li>
<li><p><a class="reference internal" href="#runtime-for-eig" id="id6">Runtime for Eig</a></p></li>
<li><p><a class="reference internal" href="#registration" id="id7">Registration</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#final-example" id="id8">Final example</a></p></li>
<li><p><a class="reference internal" href="#final-graph" id="id9">Final graph</a></p></li>
</ul>
</div>
<section id="a-transformer-which-decorrelates-variables">
<h2><a class="toc-backref" href="#id1">A transformer which decorrelates variables</a><a class="headerlink" href="#a-transformer-which-decorrelates-variables" title="Permalink to this headline">¶</a></h2>
<p>This time, the eigen values are not estimated at
training time but at prediction time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mlprodict.onnxrt.shape_object</span> <span class="kn">import</span> <span class="n">ShapeObject</span>
<span class="kn">from</span> <span class="nn">mlprodict.onnxrt.ops_cpu</span> <span class="kn">import</span> <span class="n">OpRunCustom</span><span class="p">,</span> <span class="n">register_operator</span>
<span class="kn">from</span> <span class="nn">skl2onnx.algebra.onnx_ops</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">OnnxAdd</span><span class="p">,</span>
    <span class="n">OnnxCast</span><span class="p">,</span>
    <span class="n">OnnxDiv</span><span class="p">,</span>
    <span class="n">OnnxGatherElements</span><span class="p">,</span>
    <span class="n">OnnxEyeLike</span><span class="p">,</span>
    <span class="n">OnnxMatMul</span><span class="p">,</span>
    <span class="n">OnnxMul</span><span class="p">,</span>
    <span class="n">OnnxPow</span><span class="p">,</span>
    <span class="n">OnnxReduceMean</span><span class="p">,</span>
    <span class="n">OnnxShape</span><span class="p">,</span>
    <span class="n">OnnxSub</span><span class="p">,</span>
    <span class="n">OnnxTranspose</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">skl2onnx.algebra</span> <span class="kn">import</span> <span class="n">OnnxOperator</span>
<span class="kn">from</span> <span class="nn">mlprodict.onnxrt</span> <span class="kn">import</span> <span class="n">OnnxInference</span>
<span class="kn">from</span> <span class="nn">pyquickhelper.helpgen.graphviz_helper</span> <span class="kn">import</span> <span class="n">plot_graphviz</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">assert_almost_equal</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">BaseEstimator</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="kn">from</span> <span class="nn">skl2onnx.common.data_types</span> <span class="kn">import</span> <span class="n">guess_numpy_type</span><span class="p">,</span> <span class="n">guess_proto_type</span>
<span class="kn">from</span> <span class="nn">skl2onnx</span> <span class="kn">import</span> <span class="n">to_onnx</span>
<span class="kn">from</span> <span class="nn">skl2onnx</span> <span class="kn">import</span> <span class="n">update_registered_converter</span>


<span class="k">class</span> <span class="nc">LiveDecorrelateTransformer</span><span class="p">(</span><span class="n">TransformerMixin</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorrelates correlated gaussian features.</span>

<span class="sd">    :param alpha: avoids non inversible matrices</span>
<span class="sd">        by adding *alpha* identity matrix</span>

<span class="sd">    *Attributes*</span>

<span class="sd">    * `self.nf_`: number of expected features</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="n">BaseEstimator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">TransformerMixin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;sample_weights != None is not implemented.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nf_</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">mean_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">X2</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">mean_</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">X2</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X2</span> <span class="o">/</span> <span class="n">X2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">Linv</span> <span class="o">=</span> <span class="n">L</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Linv</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">diag</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">coef_</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mean_</span><span class="p">)</span> <span class="o">@</span> <span class="n">coef_</span>


<span class="k">def</span> <span class="nf">test_live_decorrelate_transformer</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>

    <span class="n">dec</span> <span class="o">=</span> <span class="n">LiveDecorrelateTransformer</span><span class="p">()</span>
    <span class="n">dec</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pred</span>
    <span class="n">cov</span> <span class="o">/=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">cov</span><span class="p">)</span>

    <span class="n">dec</span> <span class="o">=</span> <span class="n">LiveDecorrelateTransformer</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">dec</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pred</span>
    <span class="n">cov</span> <span class="o">/=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">cov</span><span class="p">)</span>

    <span class="n">st</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span>
    <span class="n">dec2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()))</span>
    <span class="n">assert_almost_equal</span><span class="p">(</span><span class="n">dec</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dec2</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>


<span class="n">test_live_decorrelate_transformer</span><span class="p">()</span>
</pre></div>
</div>
<p>Everything works as expected.</p>
</section>
<section id="extend-onnx">
<h2><a class="toc-backref" href="#id2">Extend ONNX</a><a class="headerlink" href="#extend-onnx" title="Permalink to this headline">¶</a></h2>
<p>The conversion requires one operator to compute
the eigen values and vectors. The list of
<a class="reference external" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md">ONNX operators</a> does not contain anything
which produces eigen values. It does not seem
efficient to implement an algorithm with existing
ONNX operators to find eigen values.
A new operator must be
added, we give it the same name <em>Eig</em> as in <a class="reference external" href="https://numpy.org/">numpy</a>.
It would take a matrix and would produce one or two outputs,
the eigen values and the eigen vectors.
Just for the exercise, a parameter specifies
to output the eigen vectors as a second output.</p>
<section id="new-onnx-operator">
<h3><a class="toc-backref" href="#id3">New ONNX operator</a><a class="headerlink" href="#new-onnx-operator" title="Permalink to this headline">¶</a></h3>
<p>Any unknown operator can be
added to an ONNX graph. Operators are grouped by domain,
<cite>‘’</cite> or <cite>ai.onnx</cite> refers to matrix computation.
<cite>ai.onnx.ml</cite> refers to usual machine learning models.
New domains are officially supported by <a class="reference external" href="https://github.com/onnx/onnx">onnx</a> package.
We want to create a new operator <cite>Eig</cite> of domain <cite>onnxcustom</cite>.
It must be declared in a class, then a converter can use it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OnnxEig</span><span class="p">(</span><span class="n">OnnxOperator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a custom operator not defined by ONNX</span>
<span class="sd">    specifications but in onnxruntime.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">since_version</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># last changed in this version</span>
    <span class="n">expected_inputs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)]</span>  <span class="c1"># input names and types</span>
    <span class="n">expected_outputs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;EigenValues&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">),</span>  <span class="c1"># output names and types</span>
                        <span class="p">(</span><span class="s1">&#39;EigenVectors&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)]</span>
    <span class="n">input_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># only one input is allowed</span>
    <span class="n">output_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># 1 or 2 outputs are produced</span>
    <span class="n">is_deprecated</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># obviously not deprecated</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="s1">&#39;onnxcustom&#39;</span>  <span class="c1"># domain, anything is ok</span>
    <span class="n">operator_name</span> <span class="o">=</span> <span class="s1">&#39;Eig&#39;</span>  <span class="c1"># operator name</span>
    <span class="n">past_version</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># empty as it is the first version</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eigv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param X: array or OnnxOperatorMixin</span>
<span class="sd">        :param eigv: also produces the eigen vectors</span>
<span class="sd">        :param op_version: opset version</span>
<span class="sd">        :param kwargs: additional parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">OnnxOperator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eigv</span><span class="o">=</span><span class="n">eigv</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">op_version</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="n">OnnxEig</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">eigv</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>OnnxEig(1 in) -&gt; ?
</pre></div>
</div>
<p>Now we can write the converter and
the shape calculator.</p>
</section>
<section id="shape-calculator">
<h3><a class="toc-backref" href="#id4">shape calculator</a><a class="headerlink" href="#shape-calculator" title="Permalink to this headline">¶</a></h3>
<p>Nothing new here.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">live_decorrelate_transformer_shape_calculator</span><span class="p">(</span><span class="n">operator</span><span class="p">):</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span>
    <span class="n">input_type</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="n">input_dim</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">output_type</span> <span class="o">=</span> <span class="n">input_type</span><span class="p">([</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">nf_</span><span class="p">])</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">output_type</span>
</pre></div>
</div>
</section>
<section id="converter">
<h3><a class="toc-backref" href="#id5">converter</a><a class="headerlink" href="#converter" title="Permalink to this headline">¶</a></h3>
<p>The converter is using the class <cite>OnnxEig</cite>. The code
is longer than previous converters as the computation is
more complex too.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">live_decorrelate_transformer_converter</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="c1"># shortcuts</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">raw_operator</span>
    <span class="n">opv</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">target_opset</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">outputs</span>

    <span class="c1"># We retrieve the unique input.</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># We guess its type. If the operator ingests float (or double),</span>
    <span class="c1"># it outputs float (or double).</span>
    <span class="n">proto_dtype</span> <span class="o">=</span> <span class="n">guess_proto_type</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">guess_numpy_type</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="c1"># Lines in comment specify the numpy computation</span>
    <span class="c1"># the ONNX code implements.</span>
    <span class="c1"># mean_ = numpy.mean(X, axis=0, keepdims=True)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">OnnxReduceMean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">keepdims</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>

    <span class="c1"># This is trick I often use. The converter automatically</span>
    <span class="c1"># chooses a name for every output. In big graph,</span>
    <span class="c1"># it is difficult to know which operator is producing which output.</span>
    <span class="c1"># This line just tells every node must prefix its ouputs with this string.</span>
    <span class="c1"># It also applies to all inputs nodes unless this method</span>
    <span class="c1"># was called for one of these nodes.</span>
    <span class="n">mean</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>

    <span class="c1"># X2 = X - mean_</span>
    <span class="n">X2</span> <span class="o">=</span> <span class="n">OnnxSub</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>

    <span class="c1"># V = X2.T @ X2 / X2.shape[0]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">OnnxGatherElements</span><span class="p">(</span>
        <span class="n">OnnxShape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">),</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">Nf</span> <span class="o">=</span> <span class="n">OnnxCast</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="n">proto_dtype</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>

    <span class="c1"># Every output involved in N and Nf is prefixed by &#39;N&#39;.</span>
    <span class="n">Nf</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">OnnxDiv</span><span class="p">(</span>
        <span class="n">OnnxMatMul</span><span class="p">(</span><span class="n">OnnxTranspose</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">),</span>
                   <span class="n">X2</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">),</span>
        <span class="n">Nf</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">V</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;V1&#39;</span><span class="p">)</span>

    <span class="c1"># V += numpy.identity(V.shape[0]) * self.alpha</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">OnnxAdd</span><span class="p">(</span><span class="n">V</span><span class="p">,</span>
                <span class="n">op</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">nf_</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
                <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">V</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;V2&#39;</span><span class="p">)</span>

    <span class="c1"># L, P = numpy.linalg.eig(V)</span>
    <span class="n">LP</span> <span class="o">=</span> <span class="n">OnnxEig</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">eigv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">LP</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;LP&#39;</span><span class="p">)</span>

    <span class="c1"># Linv = L ** (-0.5)</span>
    <span class="c1"># Notation LP[0] means OnnxPow is taking the first output</span>
    <span class="c1"># of operator OnnxEig, LP[1] would mean the second one</span>
    <span class="c1"># LP is not allowed as it is ambiguous</span>
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">OnnxPow</span><span class="p">(</span><span class="n">LP</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
                   <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">Linv</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;Linv&#39;</span><span class="p">)</span>

    <span class="c1"># diag = numpy.diag(Linv)</span>
    <span class="n">diag</span> <span class="o">=</span> <span class="n">OnnxMul</span><span class="p">(</span>
        <span class="n">OnnxEyeLike</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">nf_</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">nf_</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">),</span>
        <span class="n">Linv</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">diag</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;diag&#39;</span><span class="p">)</span>

    <span class="c1"># root = P @ diag @ P.transpose()</span>
    <span class="n">trv</span> <span class="o">=</span> <span class="n">OnnxTranspose</span><span class="p">(</span><span class="n">LP</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">coef_left</span> <span class="o">=</span> <span class="n">OnnxMatMul</span><span class="p">(</span><span class="n">LP</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">diag</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">coef_left</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;coef_left&#39;</span><span class="p">)</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="n">OnnxMatMul</span><span class="p">(</span><span class="n">coef_left</span><span class="p">,</span> <span class="n">trv</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">)</span>
    <span class="n">coef</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;coef&#39;</span><span class="p">)</span>

    <span class="c1"># Same part as before.</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">OnnxMatMul</span><span class="p">(</span><span class="n">X2</span><span class="p">,</span> <span class="n">coef</span><span class="p">,</span> <span class="n">op_version</span><span class="o">=</span><span class="n">opv</span><span class="p">,</span> <span class="n">output_names</span><span class="o">=</span><span class="n">out</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Y</span><span class="o">.</span><span class="n">set_onnx_name_prefix</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

    <span class="c1"># The last line specifies the final output.</span>
    <span class="c1"># Every node involved in the computation is added to the ONNX</span>
    <span class="c1"># graph at this stage.</span>
    <span class="n">Y</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="runtime-for-eig">
<h3><a class="toc-backref" href="#id6">Runtime for Eig</a><a class="headerlink" href="#runtime-for-eig" title="Permalink to this headline">¶</a></h3>
<p>Here comes the new part. The python runtime does not
implement any runtime for <em>Eig</em>. We need to tell the runtime
to compute eigen values and vectors every time operator <em>Eig</em>
is called. That means implementing two methods,
one to compute, one to infer the shape of the results.
The first one is mandatory, the second one can return an
empty shape if it depends on the inputs. If it is known,
the runtime may be able to optimize the computation,
by reducing allocation for example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OpEig</span><span class="p">(</span><span class="n">OpRunCustom</span><span class="p">):</span>

    <span class="n">op_name</span> <span class="o">=</span> <span class="s1">&#39;Eig&#39;</span>  <span class="c1"># operator name</span>
    <span class="n">atts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eigv&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>  <span class="c1"># operator parameters</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_node</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># constructor, every parameter is added a member</span>
        <span class="n">OpRunCustom</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">onnx_node</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
                             <span class="n">expected_attributes</span><span class="o">=</span><span class="n">OpEig</span><span class="o">.</span><span class="n">atts</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># computation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">infer_shapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># shape inference, if you don&#39;t know what to</span>
        <span class="c1"># write, just return `ShapeObject(None)`</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigv</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">ShapeObject</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;Values&#39;</span><span class="p">),</span>
                <span class="n">ShapeObject</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;Vectors&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ShapeObject</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="registration">
<h3><a class="toc-backref" href="#id7">Registration</a><a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">update_registered_converter</span><span class="p">(</span>
    <span class="n">LiveDecorrelateTransformer</span><span class="p">,</span> <span class="s2">&quot;SklearnLiveDecorrelateTransformer&quot;</span><span class="p">,</span>
    <span class="n">live_decorrelate_transformer_shape_calculator</span><span class="p">,</span>
    <span class="n">live_decorrelate_transformer_converter</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="final-example">
<h2><a class="toc-backref" href="#id8">Final example</a><a class="headerlink" href="#final-example" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>

<span class="n">dec</span> <span class="o">=</span> <span class="n">LiveDecorrelateTransformer</span><span class="p">()</span>
<span class="n">dec</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">onx</span> <span class="o">=</span> <span class="n">to_onnx</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

<span class="n">register_operator</span><span class="p">(</span><span class="n">OpEig</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Eig&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">oinf</span> <span class="o">=</span> <span class="n">OnnxInference</span><span class="p">(</span><span class="n">onx</span><span class="p">)</span>

<span class="n">exp</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="n">got</span> <span class="o">=</span> <span class="n">oinf</span><span class="o">.</span><span class="n">run</span><span class="p">({</span><span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)})[</span><span class="s1">&#39;variable&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


<span class="nb">print</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">got</span><span class="p">))</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>(0.0, 0.0)
</pre></div>
</div>
<p>It works!</p>
</section>
<section id="final-graph">
<h2><a class="toc-backref" href="#id9">Final graph</a><a class="headerlink" href="#final-graph" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">oinf</span> <span class="o">=</span> <span class="n">OnnxInference</span><span class="p">(</span><span class="n">onx</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plot_graphviz</span><span class="p">(</span><span class="n">oinf</span><span class="o">.</span><span class="n">to_dot</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<img alt="plot pextend python runtime" class="sphx-glr-single-img" src="../_images/sphx_glr_plot_pextend_python_runtime_001.png" />
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.510 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-tutorial-plot-pextend-python-runtime-py">
<div class="binder-badge docutils container">
<a class="reference external image-reference" href="https://mybinder.org/v2/gh/onnx/sklearn-onnx/master?filepath=notebooks/auto_tutorial/plot_pextend_python_runtime.ipynb"><img alt="Launch binder" src="../_images/binder_badge_logo1.svg" width="150px" /></a>
</div>
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/2f8d04b47600766e780eb9c1b5b5a68d/plot_pextend_python_runtime.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">plot_pextend_python_runtime.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/1e0097aeb4f54b635ceba842f3e6889a/plot_pextend_python_runtime.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">plot_pextend_python_runtime.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo_main.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Fast design with a python runtime</a><ul>
<li><a class="reference internal" href="#a-transformer-which-decorrelates-variables">A transformer which decorrelates variables</a></li>
<li><a class="reference internal" href="#extend-onnx">Extend ONNX</a><ul>
<li><a class="reference internal" href="#new-onnx-operator">New ONNX operator</a></li>
<li><a class="reference internal" href="#shape-calculator">shape calculator</a></li>
<li><a class="reference internal" href="#converter">converter</a></li>
<li><a class="reference internal" href="#runtime-for-eig">Runtime for Eig</a></li>
<li><a class="reference internal" href="#registration">Registration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#final-example">Final example</a></li>
<li><a class="reference internal" href="#final-graph">Final graph</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation index</a><ul>
  <li><a href="../index_tutorial.html">Tutorial</a><ul>
  <li><a href="../tutorial_3_new_operator.html">Extend ONNX, extend runtime</a><ul>
      <li>Previous: <a href="../tutorial_3_new_operator.html" title="previous chapter">Extend ONNX, extend runtime</a></li>
      <li>Next: <a href="plot_qextend_onnxruntime.html" title="next chapter">Fast runtime with onnxruntime</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/auto_tutorial/plot_pextend_python_runtime.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">
    &copy; Copyright 2018-2021, Microsoft.
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.1.0.
  </div>
  
  </body>
</html>